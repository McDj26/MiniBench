{"project_name":"JCTools","relative_path":"JCTools/jctools-core/src/main/java/org/jctools/queues/BaseLinkedQueue.java","file_name":"BaseLinkedQueue.java","package":"org.jctools.queues","class_name":"BaseLinkedQueuePad0","method_name":"size","source_code":"@Override\npublic final int size()\n{\n    // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n    LinkedQueueNode<E> chaserNode = lvConsumerNode();\n    LinkedQueueNode<E> producerNode = lvProducerNode();\n    int size = 0;\n    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n    while (chaserNode != producerNode && // don't go passed producer node\n        chaserNode != null && // stop at last node\n        size < Integer.MAX_VALUE) // stop at max int\n    {\n        LinkedQueueNode<E> next;\n        next = chaserNode.lvNext();\n        // check if this node has been consumed, if so return what we have\n        if (next == chaserNode)\n        {\n            return size;\n        }\n        chaserNode = next;\n        size++;\n    }\n    return size;\n}","context":"package org.jctools.queues;\nimport java.util.AbstractQueue;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\nabstract class BaseLinkedQueuePad0 extends AbstractQueue<E> implements MessagePassingQueue<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n}\nabstract class BaseLinkedQueueProducerNodeRef extends BaseLinkedQueuePad0<E> {\n    static final long P_NODE_OFFSET;\n    volatile private LinkedQueueNode<E> producerNode;\n    final  spProducerNode(LinkedQueueNode<E> newValue);\n    final  soProducerNode(LinkedQueueNode<E> newValue);\n    final LinkedQueueNode<E> lvProducerNode();\n    final boolean casProducerNode(LinkedQueueNode<E> expect, LinkedQueueNode<E> newValue);\n    final LinkedQueueNode<E> lpProducerNode();\n}\nabstract class BaseLinkedQueuePad1 extends BaseLinkedQueueProducerNodeRef<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\nabstract class BaseLinkedQueueConsumerNodeRef extends BaseLinkedQueuePad1<E> {\n    static final private long C_NODE_OFFSET;\n    private LinkedQueueNode<E> consumerNode;\n    final  spConsumerNode(LinkedQueueNode<E> newValue);\n    final LinkedQueueNode<E> lvConsumerNode();\n    final LinkedQueueNode<E> lpConsumerNode();\n}\nabstract class BaseLinkedQueuePad2 extends BaseLinkedQueueConsumerNodeRef<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\nabstract class BaseLinkedQueue extends BaseLinkedQueuePad2<E> {\n    final public Iterator<E> iterator();\n    public String toString();\n    protected final LinkedQueueNode<E> newNode();\n    protected final LinkedQueueNode<E> newNode(E e);\n    final public int size();\n    public boolean isEmpty();\n    protected E getSingleConsumerNodeValue(LinkedQueueNode<E> currConsumerNode, LinkedQueueNode<E> nextNode);\n    public E poll();\n    public E peek();\n    LinkedQueueNode<E> spinWaitForNextNode(LinkedQueueNode<E> currNode);\n    public E relaxedPoll();\n    public E relaxedPeek();\n    public boolean relaxedOffer(E e);\n    public int drain(Consumer<E> c, int limit);\n    public int drain(Consumer<E> c);\n    public  drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit);\n    public int capacity();\n}","docstring":"/**\n     * {@inheritDoc} <br>\n     * <p>\n     * IMPLEMENTATION NOTES:<br>\n     * This is an O(n) operation as we run through all the nodes and count them.<br>\n     * The accuracy of the value returned by this method is subject to races with producer/consumer threads. In\n     * particular when racing with the consumer thread this method may under estimate the size.<br>\n     *\n     * @see java.util.Queue#size()\n     */"}