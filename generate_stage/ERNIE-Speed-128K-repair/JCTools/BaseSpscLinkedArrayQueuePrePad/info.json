{"project_name":"JCTools","relative_path":"JCTools/jctools-core/src/main/java/org/jctools/queues/BaseSpscLinkedArrayQueue.java","file_name":"BaseSpscLinkedArrayQueue.java","package":"org.jctools.queues","class_name":"BaseSpscLinkedArrayQueuePrePad","method_name":"offer","source_code":"@Override\npublic boolean offer(final E e)\n{\n    // Objects.requireNonNull(e);\n    if (null == e)\n    {\n        throw new NullPointerException();\n    }\n    // local load of field to avoid repeated loads after volatile reads\n    final E[] buffer = producerBuffer;\n    final long index = lpProducerIndex();\n    final long mask = producerMask;\n    final long offset = calcCircularRefElementOffset(index, mask);\n    // expected hot path\n    if (index < producerBufferLimit)\n    {\n        writeToQueue(buffer, e, index, offset);\n        return true;\n    }\n    return offerColdPath(buffer, mask, index, offset, e, null);\n}","context":"package org.jctools.queues;\nimport org.jctools.queues.IndexedQueueSizeUtil.IndexedQueue;\nimport org.jctools.util.PortableJvmInfo;\nimport java.util.AbstractQueue;\nimport java.util.Iterator;\nimport static org.jctools.queues.LinkedArrayQueueUtil.length;\nimport static org.jctools.queues.LinkedArrayQueueUtil.nextArrayOffset;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\nimport static org.jctools.util.UnsafeRefArrayAccess;\nabstract class BaseSpscLinkedArrayQueuePrePad extends AbstractQueue<E> implements IndexedQueue {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n}\nabstract class BaseSpscLinkedArrayQueueConsumerColdFields extends BaseSpscLinkedArrayQueuePrePad<E> {\n    protected long consumerMask;\n    protected E consumerBuffer;\n}\nabstract class BaseSpscLinkedArrayQueueConsumerField extends BaseSpscLinkedArrayQueueConsumerColdFields<E> {\n    static final private long C_INDEX_OFFSET;\n    volatile private long consumerIndex;\n    final public long lvConsumerIndex();\n    final long lpConsumerIndex();\n    final  soConsumerIndex(long newValue);\n}\nabstract class BaseSpscLinkedArrayQueueL2Pad extends BaseSpscLinkedArrayQueueConsumerField<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\nabstract class BaseSpscLinkedArrayQueueProducerFields extends BaseSpscLinkedArrayQueueL2Pad<E> {\n    static final private long P_INDEX_OFFSET;\n    volatile private long producerIndex;\n    final public long lvProducerIndex();\n    final  soProducerIndex(long newValue);\n    final long lpProducerIndex();\n}\nabstract class BaseSpscLinkedArrayQueueProducerColdFields extends BaseSpscLinkedArrayQueueProducerFields<E> {\n    protected long producerBufferLimit;\n    protected long producerMask;\n    protected E producerBuffer;\n}\nabstract class BaseSpscLinkedArrayQueue extends BaseSpscLinkedArrayQueueProducerColdFields<E> implements MessagePassingQueue<E>, QueueProgressIndicators {\n    static final private Object JUMP;\n    final public Iterator<E> iterator();\n    final public int size();\n    final public boolean isEmpty();\n    public String toString();\n    public long currentProducerIndex();\n    public long currentConsumerIndex();\n    protected final  soNext(E curr, E next);\n    protected final E lvNextArrayAndUnlink(E curr);\n    public boolean relaxedOffer(E e);\n    public E relaxedPoll();\n    public E relaxedPeek();\n    public int drain(Consumer<E> c);\n    public int fill(Supplier<E> s);\n    public int drain(Consumer<E> c, int limit);\n    public int fill(Supplier<E> s, int limit);\n    public  drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit);\n    public  fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit);\n    public boolean offer(E e);\n    abstract boolean offerColdPath(E buffer, long mask, long pIndex, long offset, E v, Supplier<E> s);\n    public E poll();\n    public E peek();\n    final  linkOldToNew(long currIndex, E oldBuffer, long offset, E newBuffer, long offsetInNew, E e);\n    final  writeToQueue(E buffer, E e, long index, long offset);\n    private E newBufferPeek(E buffer, long index);\n    private E newBufferPoll(E buffer, long index);\n}","docstring":"/**\n     * {@inheritDoc}\n     * <p>\n     * This implementation is correct for single producer thread use only.\n     */"}