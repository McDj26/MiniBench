{"project_name":"JCTools","relative_path":"JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java","file_name":"NonBlockingHashMap.java","package":"org.jctools.maps","class_name":"NonBlockingHashMap","method_name":"toString","source_code":"@Override\npublic String toString() {\n  Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n  if( !i.hasNext())\n    return \"{}\";\n  StringBuilder sb = new StringBuilder();\n  sb.append('{');\n  for (;;) {\n    Entry<TypeK,TypeV> e = i.next();\n    TypeK key = e.getKey();\n    TypeV value = e.getValue();\n    sb.append(key   == this ? \"(this Map)\" : key);\n    sb.append('=');\n    sb.append(value == this ? \"(this Map)\" : value);\n    if( !i.hasNext())\n      return sb.append('}').toString();\n    sb.append(\", \");\n  }\n}","context":"package org.jctools.maps;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport org.jctools.util.RangeUtil;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\npublic class NonBlockingHashMap extends AbstractMap<TypeK, TypeV> implements ConcurrentMap<TypeK, TypeV>, Cloneable, Serializable {\n    static final private long serialVersionUID;\n    static final private int REPROBE_LIMIT;\n    static final private int _Obase;\n    static final private int _Oscale;\n    static final private int _Olog;\n    static private long rawIndex(Object ary, int idx);\n    static final private long _kvs_offset;\n    final private boolean CAS_kvs(Object oldkvs, Object newkvs);\n    static final private class Prime {\n        final Object _V;\n        Prime(Object V);\n        static Object unbox(Object V);\n    }\n    static final private int hash(Object key);\n    transient private Object _kvs;\n    static final private CHM chm(Object kvs);\n    static final private int[] hashes(Object kvs);\n    static final private int len(Object kvs);\n    transient private long _last_resize_milli;\n    static final private int MIN_SIZE_LOG;\n    static final private int MIN_SIZE;\n    static final private Object NO_MATCH_OLD;\n    static final private Object MATCH_ANY;\n    static public final Object TOMBSTONE;\n    static final private Prime TOMBPRIME;\n    static final private Object key(Object kvs, int idx);\n    static final private Object val(Object kvs, int idx);\n    static final private boolean CAS_key(Object kvs, int idx, Object old, Object key);\n    static final private boolean CAS_val(Object kvs, int idx, Object old, Object val);\n    final public  print();\n    final private  print(Object kvs);\n    final private  print2(Object kvs);\n    transient private ConcurrentAutoTable _reprobes;\n    public long reprobes();\n    static private int reprobe_limit(int len);\n    public NonBlockingHashMap();\n    public NonBlockingHashMap(int initial_sz);\n    final private  initialize(int initial_sz);\n    protected final  initialize();\n    public int size();\n    public boolean isEmpty();\n    public boolean containsKey(Object key);\n    public boolean contains(Object val);\n    public TypeV put(TypeK key, TypeV val);\n    public TypeV putIfAbsent(TypeK key, TypeV val);\n    public TypeV remove(Object key);\n    public boolean remove(Object key, Object val);\n    public TypeV replace(TypeK key, TypeV val);\n    public boolean replace(TypeK key, TypeV oldValue, TypeV newValue);\n    static private boolean objectsEquals(Object a, Object b);\n    final public TypeV putIfMatchAllowNull(Object key, Object newVal, Object oldVal);\n    final public TypeV putIfMatch(Object key, Object newVal, Object oldVal);\n    public  putAll(Map<TypeK, TypeV> m);\n    public  clear();\n    public boolean containsValue(Object val);\n    protected  rehash();\n    public Object clone();\n    public String toString();\n    static private boolean keyeq(Object K, Object key, int[] hashes, int hash, int fullhash);\n    public TypeV get(Object key);\n    static final private Object get_impl(NonBlockingHashMap topmap, Object kvs, Object key);\n    public TypeK getk(TypeK key);\n    static final private Object getk_impl(NonBlockingHashMap topmap, Object kvs, Object key);\n    volatile static int DUMMY_VOLATILE;\n    static final private Object putIfMatch0(NonBlockingHashMap topmap, Object kvs, Object key, Object putval, Object expVal);\n    final private Object help_copy(Object helper);\n    static final private class CHM {\n        final private ConcurrentAutoTable _size;\n        public int size();\n        final private ConcurrentAutoTable _slots;\n        public int slots();\n        volatile Object _newkvs;\n        static final private AtomicReferenceFieldUpdater<CHM, Object> _newkvsUpdater;\n        boolean CAS_newkvs(Object newkvs);\n        volatile long _resizers;\n        static final private AtomicLongFieldUpdater<CHM> _resizerUpdater;\n        CHM(ConcurrentAutoTable size);\n        final private boolean tableFull(int reprobe_cnt, int len);\n        final private Object resize(NonBlockingHashMap topmap, Object kvs);\n        volatile long _copyIdx;\n        static final private AtomicLongFieldUpdater<CHM> _copyIdxUpdater;\n        volatile long _copyDone;\n        static final private AtomicLongFieldUpdater<CHM> _copyDoneUpdater;\n        final private  help_copy_impl(NonBlockingHashMap topmap, Object oldkvs, boolean copy_all);\n        final private Object copy_slot_and_check(NonBlockingHashMap topmap, Object oldkvs, int idx, Object should_help);\n        final private  copy_check_and_promote(NonBlockingHashMap topmap, Object oldkvs, int workdone);\n        private boolean copy_slot(NonBlockingHashMap topmap, int idx, Object oldkvs, Object newkvs);\n    }\n    private class SnapshotV implements Iterator<TypeV>, Enumeration<TypeV> {\n        final Object _sskvs;\n        public SnapshotV();\n        int length();\n        Object key(int idx);\n        private int _idx;\n        private Object _nextK, _prevK;\n        private TypeV _nextV, _prevV;\n        public boolean hasNext();\n        public TypeV next();\n        public  removeKey();\n        public  remove();\n        public TypeV nextElement();\n        public boolean hasMoreElements();\n    }\n    public Object raw_array();\n    public Enumeration<TypeV> elements();\n    public Collection<TypeV> values();\n    private class SnapshotK implements Iterator<TypeK>, Enumeration<TypeK> {\n        final SnapshotV _ss;\n        public SnapshotK();\n        public  remove();\n        public TypeK next();\n        public boolean hasNext();\n        public TypeK nextElement();\n        public boolean hasMoreElements();\n    }\n    public Enumeration<TypeK> keys();\n    public Set<TypeK> keySet();\n    private class NBHMEntry extends AbstractEntry<TypeK, TypeV> {\n        NBHMEntry(TypeK k, TypeV v);\n        public TypeV setValue(TypeV val);\n    }\n    private class SnapshotE implements Iterator<Map> {\n        final SnapshotV _ss;\n        public SnapshotE();\n        public  remove();\n        public Map next();\n        public boolean hasNext();\n    }\n    public Set<Map> entrySet();\n    private  writeObject(java s)throws IOException;\n    private  readObject(java s)throws IOException, ClassNotFoundException;\n}","docstring":"/**\n   * Returns a string representation of this map.  The string representation\n   * consists of a list of key-value mappings in the order returned by the\n   * map's <tt>entrySet</tt> view's iterator, enclosed in braces\n   * (<tt>\"{}\"</tt>).  Adjacent mappings are separated by the characters\n   * <tt>\", \"</tt> (comma and space).  Each key-value mapping is rendered as\n   * the key followed by an equals sign (<tt>\"=\"</tt>) followed by the\n   * associated value.  Keys and values are converted to strings as by\n   * {@link String#valueOf(Object)}.\n   *\n   * @return a string representation of this map\n   */"}