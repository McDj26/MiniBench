{"project_name":"commons-math","relative_path":"commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java","file_name":"AccurateMathCalc.java","package":"org.apache.commons.math4.core.jdkmath","class_name":"AccurateMathCalc","method_name":"splitReciprocal","source_code":"static void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n    /* Resplit */\n    resplit(result);\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}","context":"package org.apache.commons.math4.core.jdkmath;\nimport java.io.PrintStream;\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}","docstring":"/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */"}