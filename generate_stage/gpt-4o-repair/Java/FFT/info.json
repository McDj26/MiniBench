{"project_name":"Java","relative_path":"Java/src/main/java/com/thealgorithms/maths/FFT.java","file_name":"FFT.java","package":"com.thealgorithms.maths","class_name":"FFT","method_name":"fft","source_code":"public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}","context":"package com.thealgorithms.maths;\nimport java.util.ArrayList;\nimport java.util.Collections;\npublic class FFT {\n    static class Complex {\n        private double real, img;\n        public Complex();\n        public Complex(double r, double i);\n        public double getReal();\n        public double getImaginary();\n        public Complex add(Complex z);\n        public Complex subtract(Complex z);\n        public Complex multiply(Complex z);\n        public Complex multiply(double n);\n        public Complex conjugate();\n        public double abs();\n        public Complex divide(Complex z);\n        public Complex divide(double n);\n    }\n    static public ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse);\n    static public int findLog2(int N);\n    static public ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x);\n    static public ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x);\n    static private int reverseBits(int num, int log2N);\n    static private  paddingPowerOfTwo(ArrayList<Complex> x);\n}","docstring":"/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */"}