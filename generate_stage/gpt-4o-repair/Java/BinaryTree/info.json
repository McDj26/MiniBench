{"project_name":"Java","relative_path":"Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java","file_name":"BinaryTree.java","package":"com.thealgorithms.datastructures.trees","class_name":"BinaryTree","method_name":"remove","source_code":"public boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n            temp.right.parent = temp.parent;\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n            temp.left.parent = temp.parent;\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}","context":"package com.thealgorithms.datastructures.trees;\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class BinaryTree {\n    static class Node {\n        public int data;\n        public Node left;\n        public Node right;\n        public Node parent;\n        public Node(int value);\n    }\n    private Node root;\n    public BinaryTree();\n    public BinaryTree(Node root);\n    public Node find(int key);\n    public  put(int value);\n    public boolean remove(int value);\n    public Node findSuccessor(Node n);\n    public Node getRoot();\n    public  inOrder(Node localRoot);\n    public  preOrder(Node localRoot);\n    public  postOrder(Node localRoot);\n    public  bfs(Node localRoot);\n}","docstring":"/**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */"}