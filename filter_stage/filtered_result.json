[
  {
    "project_name": "apollo",
    "relative_path": "apollo/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/eureka/ApolloEurekaClientConfig.java",
    "file_name": "ApolloEurekaClientConfig.java",
    "package": "com.ctrip.framework.apollo.biz.eureka",
    "class_name": "ApolloEurekaClientConfig",
    "method_name": "getEurekaServerServiceUrls",
    "source_code": "@Override\npublic List<String> getEurekaServerServiceUrls(String myZone) {\n  List<String> urls = bizConfig.eurekaServiceUrls();\n  return CollectionUtils.isEmpty(urls) ? super.getEurekaServerServiceUrls(myZone) : urls;\n}",
    "context": "package com.ctrip.framework.apollo.biz.eureka;\nimport com.ctrip.framework.apollo.biz.config.BizConfig;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.event.ApplicationReadyEvent;\nimport org.springframework.cloud.context.scope.refresh.RefreshScope;\nimport org.springframework.cloud.netflix.eureka.EurekaClientConfigBean;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\nimport java.util.List;\npublic class ApolloEurekaClientConfig extends EurekaClientConfigBean {\n    final private BizConfig bizConfig;\n    final private RefreshScope refreshScope;\n    static final private String EUREKA_CLIENT_BEAN_NAME;\n    public ApolloEurekaClientConfig(BizConfig bizConfig, RefreshScope refreshScope);\n    public List<String> getEurekaServerServiceUrls(String myZone);\n    public  listenApplicationReadyEvent(ApplicationReadyEvent event);\n    private  refreshEurekaClient();\n    public boolean equals(Object o);\n}",
    "docstring": "/**\n   * Assert only one zone: defaultZone, but multiple environments.\n   */"
  },
  {
    "project_name": "apollo",
    "relative_path": "apollo/apollo-common/src/main/java/com/ctrip/framework/apollo/common/utils/BeanUtils.java",
    "file_name": "BeanUtils.java",
    "package": "com.ctrip.framework.apollo.common.utils",
    "class_name": "BeanUtils",
    "method_name": "mapByKey",
    "source_code": "@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> mapByKey(String key, List<?> list) {\n  Map<K, V> map = new HashMap<>();\n  if (CollectionUtils.isEmpty(list)) {\n    return map;\n  }\n  try {\n    Class<?> clazz = list.get(0).getClass();\n    Field field = deepFindField(clazz, key);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Could not find the key\");\n    }\n    field.setAccessible(true);\n    for (Object o : list) {\n      map.put((K) field.get(o), (V) o);\n    }\n  } catch (Exception e) {\n    throw new BeanUtilsException(e);\n  }\n  return map;\n}",
    "context": "package com.ctrip.framework.apollo.common.utils;\nimport com.ctrip.framework.apollo.common.exception.BeanUtilsException;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.util.CollectionUtils;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\npublic class BeanUtils {\n    static public List<T> batchTransform(Class<T> clazz, List<> srcList);\n    static public T transform(Class<T> clazz, Object src);\n    static private String getNullPropertyNames(Object source);\n    static public Map<K, V> mapByKey(String key, List<> list);\n    static public Map<K, List<V>> aggByKeyToList(String key, List<> list);\n    static public Set<K> toPropertySet(String key, List<> list);\n    static private Field deepFindField(Class<> clazz, String key);\n    static public Object getProperty(Object obj, String fieldName);\n    static public  setProperty(Object obj, String fieldName, Object value);\n    static public  copyProperties(Object source, Object target, String ignoreProperties);\n    static public  copyEntityProperties(Object source, Object target);\n    static final private String COPY_IGNORED_PROPERTIES;\n}",
    "docstring": "/**\n   * 用于将一个列表转换为列表中的对象的某个属性映射到列表中的对象\n   *\n   * <pre>\n   *      List<UserDTO> userList = userService.queryUsers();\n   *      Map<Integer, userDTO> userIdToUser = BeanUtil.mapByKey(\"userId\", userList);\n   * </pre>\n   *\n   * @param key 属性名\n   */"
  },
  {
    "project_name": "apollo",
    "relative_path": "apollo/apollo-portal/src/main/java/com/ctrip/framework/apollo/portal/environment/Env.java",
    "file_name": "Env.java",
    "package": "com.ctrip.framework.apollo.portal.environment",
    "class_name": "Env",
    "method_name": "getWellFormName",
    "source_code": "private static String getWellFormName(String envName) {\n  if (StringUtils.isBlank(envName)) {\n    return \"\";\n  }\n  String envWellFormName = envName.trim().toUpperCase();\n  // special case for production in case of typo\n  if (\"PROD\".equals(envWellFormName)) {\n    return Env.PRO.name;\n  }\n  // special case that FAT & FWS should map to FAT\n  if (\"FWS\".equals(envWellFormName)) {\n    return Env.FAT.name;\n  }\n  return envWellFormName;\n}",
    "context": "package com.ctrip.framework.apollo.portal.environment;\nimport com.ctrip.framework.apollo.core.utils.StringUtils;\nimport com.google.common.base.Preconditions;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class Env {\n    static final private Logger logger;\n    static final private Map<String, Env> STRING_ENV_MAP;\n    static public final Env LOCAL;\n    static public final Env DEV;\n    static public final Env FAT;\n    static public final Env FWS;\n    static public final Env UAT;\n    static public final Env LPT;\n    static public final Env PRO;\n    static public final Env TOOLS;\n    static public final Env UNKNOWN;\n    final private String name;\n    private Env(String name);\n    static private String getWellFormName(String envName);\n    static public Env transformEnv(String envName);\n    static public boolean exists(String name);\n    static public Env addEnvironment(String name);\n    static public Env valueOf(String name);\n    static public Env fromString(String env);\n    static Map<Env, String> transformToEnvMap(Map<String, String> metaServerAddresses);\n    public boolean equals(Object o);\n    public int hashCode();\n    public String toString();\n    public String getName();\n}",
    "docstring": "/**\n   * add some change to environment name trim and to upper\n   *\n   * @param envName\n   * @return\n   */"
  },
  {
    "project_name": "commons-math",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "file_name": "AccurateMathCalc.java",
    "package": "org.apache.commons.math4.core.jdkmath",
    "class_name": "AccurateMathCalc",
    "method_name": "slowCos",
    "source_code": "static double slowCos(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) != 0) { // skip odd entries\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) { // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0]; ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}",
    "context": "package org.apache.commons.math4.core.jdkmath;\nimport java.io.PrintStream;\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}",
    "docstring": "/**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */"
  },
  {
    "project_name": "commons-math",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "file_name": "AccurateMathCalc.java",
    "package": "org.apache.commons.math4.core.jdkmath",
    "class_name": "AccurateMathCalc",
    "method_name": "slowexp",
    "source_code": "static double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}",
    "context": "package org.apache.commons.math4.core.jdkmath;\nimport java.io.PrintStream;\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}",
    "docstring": "/**\n     *  For x between 0 and 1, returns exp(x), uses extended precision.\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n     *  @return exp(x)\n     */"
  },
  {
    "project_name": "commons-math",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "file_name": "AccurateMathCalc.java",
    "package": "org.apache.commons.math4.core.jdkmath",
    "class_name": "AccurateMathCalc",
    "method_name": "splitReciprocal",
    "source_code": "static void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n    /* Resplit */\n    resplit(result);\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}",
    "context": "package org.apache.commons.math4.core.jdkmath;\nimport java.io.PrintStream;\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}",
    "docstring": "/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */"
  },
  {
    "project_name": "commons-math",
    "relative_path": "commons-math/commons-math-legacy-core/src/main/java/org/apache/commons/math4/legacy/core/Pair.java",
    "file_name": "Pair.java",
    "package": "org.apache.commons.math4.legacy.core",
    "class_name": "Pair",
    "method_name": "equals",
    "source_code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (!(o instanceof Pair)) {\n        return false;\n    } else {\n        Pair<?, ?> oP = (Pair<?, ?>) o;\n        return (key == null ?\n                oP.key == null :\n                key.equals(oP.key)) &&\n            (value == null ?\n             oP.value == null :\n             value.equals(oP.value));\n    }\n}",
    "context": "package org.apache.commons.math4.legacy.core;\npublic class Pair {\n    final private K key;\n    final private V value;\n    public Pair(K k, V v);\n    public Pair(Pair<K, V> entry);\n    public K getKey();\n    public V getValue();\n    public K getFirst();\n    public V getSecond();\n    public boolean equals(Object o);\n    public int hashCode();\n    public String toString();\n    static public Pair<K, V> create(K k, V v);\n}",
    "docstring": "/**\n     * Compare the specified object with this entry for equality.\n     *\n     * @param o Object.\n     * @return {@code true} if the given object is also a map entry and\n     * the two entries represent the same mapping.\n     */"
  },
  {
    "project_name": "commons-math",
    "relative_path": "commons-math/commons-math-neuralnet/src/main/java/org/apache/commons/math4/neuralnet/Neuron.java",
    "file_name": "Neuron.java",
    "package": "org.apache.commons.math4.neuralnet",
    "class_name": "Neuron",
    "method_name": "compareAndSetFeatures",
    "source_code": "public boolean compareAndSetFeatures(double[] expect,\n                                     double[] update) {\n    if (update.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     update.length, size);\n    }\n    // Get the internal reference. Note that this must not be a copy;\n    // otherwise the \"compareAndSet\" below will always fail.\n    final double[] current = features.get();\n    if (!containSameValues(current, expect)) {\n        // Some other thread already modified the state.\n        return false;\n    }\n    // Increment attempt counter.\n    numberOfAttemptedUpdates.incrementAndGet();\n    if (features.compareAndSet(current, update.clone())) {\n        // The current thread could atomically update the state (attempt succeeded).\n        numberOfSuccessfulUpdates.incrementAndGet();\n        return true;\n    } else {\n        // Some other thread came first (attempt failed).\n        return false;\n    }\n}",
    "context": "package org.apache.commons.math4.neuralnet;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.commons.numbers.core.Precision;\nimport org.apache.commons.math4.neuralnet.internal.NeuralNetException;\npublic class Neuron {\n    final private long identifier;\n    final private int size;\n    final private AtomicReference<double[]> features;\n    final private AtomicLong numberOfAttemptedUpdates;\n    final private AtomicLong numberOfSuccessfulUpdates;\n    Neuron(long identifier, double[] features);\n    public synchronized Neuron copy();\n    public long getIdentifier();\n    public int getSize();\n    public double[] getFeatures();\n    public boolean compareAndSetFeatures(double[] expect, double[] update);\n    public long getNumberOfAttemptedUpdates();\n    public long getNumberOfSuccessfulUpdates();\n    private boolean containSameValues(double[] current, double[] expect);\n}",
    "docstring": "/**\n     * Tries to atomically update the neuron's features.\n     * Update will be performed only if the expected values match the\n     * current values.<br>\n     * In effect, when concurrent threads call this method, the state\n     * could be modified by one, so that it does not correspond to the\n     * the state assumed by another.\n     * Typically, a caller {@link #getFeatures() retrieves the current state},\n     * and uses it to compute the new state.\n     * During this computation, another thread might have done the same\n     * thing, and updated the state: If the current thread were to proceed\n     * with its own update, it would overwrite the new state (which might\n     * already have been used by yet other threads).\n     * To prevent this, the method does not perform the update when a\n     * concurrent modification has been detected, and returns {@code false}.\n     * When this happens, the caller should fetch the new current state,\n     * redo its computation, and call this method again.\n     *\n     * @param expect Current values of the features, as assumed by the caller.\n     * Update will never succeed if the contents of this array does not match\n     * the values returned by {@link #getFeatures()}.\n     * @param update Features's new values.\n     * @return {@code true} if the update was successful, {@code false}\n     * otherwise.\n     * @throws IllegalArgumentException if the length of {@code update} is\n     * not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     */"
  },
  {
    "project_name": "commons-math",
    "relative_path": "commons-math/commons-math-neuralnet/src/main/java/org/apache/commons/math4/neuralnet/Neuron.java",
    "file_name": "Neuron.java",
    "package": "org.apache.commons.math4.neuralnet",
    "class_name": "Neuron",
    "method_name": "containSameValues",
    "source_code": "private boolean containSameValues(double[] current,\n                                  double[] expect) {\n    if (expect.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     expect.length, size);\n    }\n    for (int i = 0; i < size; i++) {\n        if (!Precision.equals(current[i], expect[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
    "context": "package org.apache.commons.math4.neuralnet;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.commons.numbers.core.Precision;\nimport org.apache.commons.math4.neuralnet.internal.NeuralNetException;\npublic class Neuron {\n    final private long identifier;\n    final private int size;\n    final private AtomicReference<double[]> features;\n    final private AtomicLong numberOfAttemptedUpdates;\n    final private AtomicLong numberOfSuccessfulUpdates;\n    Neuron(long identifier, double[] features);\n    public synchronized Neuron copy();\n    public long getIdentifier();\n    public int getSize();\n    public double[] getFeatures();\n    public boolean compareAndSetFeatures(double[] expect, double[] update);\n    public long getNumberOfAttemptedUpdates();\n    public long getNumberOfSuccessfulUpdates();\n    private boolean containSameValues(double[] current, double[] expect);\n}",
    "docstring": "/**\n     * Checks whether the contents of both arrays is the same.\n     *\n     * @param current Current values.\n     * @param expect Expected values.\n     * @throws IllegalArgumentException if the length of {@code expect}\n     * is not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     * @return {@code true} if the arrays contain the same values.\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/audiofilters/IIRFilter.java",
    "file_name": "IIRFilter.java",
    "package": "com.thealgorithms.audiofilters",
    "class_name": "IIRFilter",
    "method_name": "process",
    "source_code": "public double process(double sample) {\n    double result = 0.0;\n    // Process\n    for (int i = 1; i <= order; i++) {\n        result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);\n    }\n    result = (result + coeffsB[0] * sample) / coeffsA[0];\n    // Feedback\n    for (int i = order - 1; i > 0; i--) {\n        historyX[i] = historyX[i - 1];\n        historyY[i] = historyY[i - 1];\n    }\n    historyX[0] = sample;\n    historyY[0] = result;\n    return result;\n}",
    "context": "package com.thealgorithms.audiofilters;\npublic class IIRFilter {\n    final private int order;\n    final private double[] coeffsA;\n    final private double[] coeffsB;\n    final private double[] historyX;\n    final private double[] historyY;\n    public IIRFilter(int order);\n    public  setCoeffs(double[] aCoeffs, double[] bCoeffs)throws IllegalArgumentException;\n    public double process(double sample);\n}",
    "docstring": "/**\n     * Process a single sample\n     *\n     * @param sample the sample to process\n     * @return the processed sample\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java",
    "file_name": "ArrayCombination.java",
    "package": "com.thealgorithms.backtracking",
    "class_name": "ArrayCombination",
    "method_name": "combination",
    "source_code": "public static List<TreeSet<Integer>> combination(int n, int k) {\n    if (n <= 0) {\n        return null;\n    }\n    length = k;\n    Integer[] arr = new Integer[n];\n    for (int i = 1; i <= n; i++) {\n        arr[i - 1] = i;\n    }\n    return Combination.combination(arr, length);\n}",
    "context": "package com.thealgorithms.backtracking;\nimport java.util;\npublic class ArrayCombination {\n    static private int length;\n    static public List<TreeSet<Integer>> combination(int n, int k);\n}",
    "docstring": "/**\n     * Find all combinations of 1..n by creating an array and using backtracking in Combination.java\n     * @param n max value of the array.\n     * @param k length of combination\n     * @return a list of all combinations of length k. If k == 0, return null.\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "file_name": "FloodFill.java",
    "package": "com.thealgorithms.backtracking",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "source_code": "public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n    putPixel(image, x, y, newColor);\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}",
    "context": "package com.thealgorithms.backtracking;\nfinal public class FloodFill {\n    private FloodFill();\n    static public int getPixel(int[][] image, int x, int y);\n    static public  putPixel(int[][] image, int x, int y, int newColor);\n    static public  floodFill(int[][] image, int x, int y, int newColor, int oldColor);\n}",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/Caesar.java",
    "file_name": "Caesar.java",
    "package": "com.thealgorithms.ciphers",
    "class_name": "Caesar",
    "method_name": "decode",
    "source_code": "public String decode(String encryptedMessage, int shift) {\n    StringBuilder decoded = new StringBuilder();\n    shift %= 26;\n    final int length = encryptedMessage.length();\n    for (int i = 0; i < length; i++) {\n        char current = encryptedMessage.charAt(i);\n        if (isCapitalLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n        } else if (isSmallLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n        } else {\n            decoded.append(current);\n        }\n    }\n    return decoded.toString();\n}",
    "context": "package com.thealgorithms.ciphers;\npublic class Caesar {\n    public String encode(String message, int shift);\n    public String decode(String encryptedMessage, int shift);\n    static private boolean isCapitalLatinLetter(char c);\n    static private boolean isSmallLatinLetter(char c);\n    public String bruteforce(String encryptedMessage);\n}",
    "docstring": "/**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/SimpleSubstitutionCipher.java",
    "file_name": "SimpleSubstitutionCipher.java",
    "package": "com.thealgorithms.ciphers",
    "class_name": "SimpleSubstitutionCipher",
    "method_name": "encode",
    "source_code": "public static String encode(String message, String cipherSmall) {\n    StringBuilder encoded = new StringBuilder();\n    // This map is used to encode\n    Map<Character, Character> cipherMap = new HashMap<>();\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n    // To handle Small and Capital letters\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n        cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n    }\n    for (int i = 0; i < message.length(); i++) {\n        if (Character.isAlphabetic(message.charAt(i))) {\n            encoded.append(cipherMap.get(message.charAt(i)));\n        } else {\n            encoded.append(message.charAt(i));\n        }\n    }\n    return encoded.toString();\n}",
    "context": "package com.thealgorithms.ciphers;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class SimpleSubstitutionCipher {\n    static public String encode(String message, String cipherSmall);\n    static public String decode(String encryptedMessage, String cipherSmall);\n}",
    "docstring": "/**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/SimpleSubstitutionCipher.java",
    "file_name": "SimpleSubstitutionCipher.java",
    "package": "com.thealgorithms.ciphers",
    "class_name": "SimpleSubstitutionCipher",
    "method_name": "decode",
    "source_code": "public static String decode(String encryptedMessage, String cipherSmall) {\n    StringBuilder decoded = new StringBuilder();\n    Map<Character, Character> cipherMap = new HashMap<>();\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n        cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n    }\n    for (int i = 0; i < encryptedMessage.length(); i++) {\n        if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n            decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n        } else {\n            decoded.append(encryptedMessage.charAt(i));\n        }\n    }\n    return decoded.toString();\n}",
    "context": "package com.thealgorithms.ciphers;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class SimpleSubstitutionCipher {\n    static public String encode(String message, String cipherSmall);\n    static public String decode(String encryptedMessage, String cipherSmall);\n}",
    "docstring": "/**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/conversions/DecimalToAnyBase.java",
    "file_name": "DecimalToAnyBase.java",
    "package": "com.thealgorithms.conversions",
    "class_name": "DecimalToAnyBase",
    "method_name": "convertToAnyBase",
    "source_code": "public static String convertToAnyBase(int inp, int base) {\n    ArrayList<Character> charArr = new ArrayList<>();\n    while (inp > 0) {\n        charArr.add(reVal(inp % base));\n        inp /= base;\n    }\n    StringBuilder str = new StringBuilder(charArr.size());\n    for (Character ch : charArr) {\n        str.append(ch);\n    }\n    return str.reverse().toString();\n}",
    "context": "package com.thealgorithms.conversions;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\npublic class DecimalToAnyBase {\n    static public  main(String args)throws Exception;\n    static public String convertToAnyBase(int inp, int base);\n    static public char reVal(int num);\n}",
    "docstring": "/**\n     * This method produces a String value of any given input decimal in any\n     * base\n     *\n     * @param inp Decimal of which we need the value in base in String format\n     * @return string format of the converted value in the given base\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/conversions/OctalToHexadecimal.java",
    "file_name": "OctalToHexadecimal.java",
    "package": "com.thealgorithms.conversions",
    "class_name": "OctalToHexadecimal",
    "method_name": "decimalToHex",
    "source_code": "public static String decimalToHex(int d) {\n    String digits = \"0123456789ABCDEF\";\n    if (d <= 0) {\n        return \"0\";\n    }\n    String hex = \"\";\n    while (d > 0) {\n        int digit = d % 16;\n        hex = digits.charAt(digit) + hex;\n        d = d / 16;\n    }\n    return hex;\n}",
    "context": "package com.thealgorithms.conversions;\nimport java.util.Scanner;\npublic class OctalToHexadecimal {\n    static public int octToDec(String s);\n    static public String decimalToHex(int d);\n    static public  main(String args);\n}",
    "docstring": "/**\n     * This method converts a Decimal number to a Hexadecimal number\n     *\n     * @param d The Decimal Number\n     * @return The Hexadecimal number\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "file_name": "BinaryTree.java",
    "package": "com.thealgorithms.datastructures.trees",
    "class_name": "BinaryTree",
    "method_name": "find",
    "source_code": "public Node find(int key) {\n    Node current = root;\n    while (current != null) {\n        if (key < current.data) {\n            if (current.left == null) {\n                return current; // The key isn't exist, returns the parent\n            }\n            current = current.left;\n        } else if (key > current.data) {\n            if (current.right == null) {\n                return current;\n            }\n            current = current.right;\n        } else { // If you find the value return it\n            return current;\n        }\n    }\n    return null;\n}",
    "context": "package com.thealgorithms.datastructures.trees;\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class BinaryTree {\n    static class Node {\n        public int data;\n        public Node left;\n        public Node right;\n        public Node parent;\n        public Node(int value);\n    }\n    private Node root;\n    public BinaryTree();\n    public BinaryTree(Node root);\n    public Node find(int key);\n    public  put(int value);\n    public boolean remove(int value);\n    public Node findSuccessor(Node n);\n    public Node getRoot();\n    public  inOrder(Node localRoot);\n    public  preOrder(Node localRoot);\n    public  postOrder(Node localRoot);\n    public  bfs(Node localRoot);\n}",
    "docstring": "/**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "file_name": "BinaryTree.java",
    "package": "com.thealgorithms.datastructures.trees",
    "class_name": "BinaryTree",
    "method_name": "remove",
    "source_code": "public boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n            temp.right.parent = temp.parent;\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n            temp.left.parent = temp.parent;\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}",
    "context": "package com.thealgorithms.datastructures.trees;\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class BinaryTree {\n    static class Node {\n        public int data;\n        public Node left;\n        public Node right;\n        public Node parent;\n        public Node(int value);\n    }\n    private Node root;\n    public BinaryTree();\n    public BinaryTree(Node root);\n    public Node find(int key);\n    public  put(int value);\n    public boolean remove(int value);\n    public Node findSuccessor(Node n);\n    public Node getRoot();\n    public  inOrder(Node localRoot);\n    public  preOrder(Node localRoot);\n    public  postOrder(Node localRoot);\n    public  bfs(Node localRoot);\n}",
    "docstring": "/**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/CursorLinkedList.java",
    "file_name": "CursorLinkedList.java",
    "package": "com.thealgorithms.datastructures.lists",
    "class_name": "CursorLinkedList",
    "method_name": "indexOf",
    "source_code": "public int indexOf(T element) {\n    Objects.requireNonNull(element);\n    Node<T> iterator = cursorSpace[head];\n    for (int i = 0; i < count; i++) {\n        if (iterator.element.equals(element)) {\n            return i;\n        }\n        iterator = cursorSpace[iterator.next];\n    }\n    return -1;\n}",
    "context": "package com.thealgorithms.datastructures.lists;\nimport java.util.Objects;\npublic class CursorLinkedList {\n    static private class Node {\n        T element;\n        int next;\n        Node(T element, int next);\n    }\n    final private int os;\n    private int head;\n    final private Node<T> cursorSpace;\n    private int count;\n    static final private int CURSOR_SPACE_SIZE;\n    public CursorLinkedList();\n    public  printList();\n    public int indexOf(T element);\n    public T get(int position);\n    public  removeByIndex(int index);\n    public  remove(T element);\n    private  free(int index);\n    public  append(T element);\n    private int alloc();\n}",
    "docstring": "/**\n     * @return the logical index of the element within the list , not the actual\n     * index of the [cursorSpace] array\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
    "file_name": "SinglyLinkedList.java",
    "package": "com.thealgorithms.datastructures.lists",
    "class_name": "SinglyLinkedList",
    "method_name": "middle",
    "source_code": "public Node middle() {\n    if (head == null) {\n        return null;\n    }\n    Node firstCounter = head;\n    Node secondCounter = firstCounter.next;\n    while (secondCounter != null && secondCounter.next != null) {\n        firstCounter = firstCounter.next;\n        secondCounter = secondCounter.next.next;\n    }\n    return firstCounter;\n}",
    "context": "package com.thealgorithms.datastructures.lists;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\npublic class SinglyLinkedList implements Iterable<Integer> {\n    private Node head;\n    private int size;\n    public SinglyLinkedList();\n    public SinglyLinkedList(Node head, int size);\n    public boolean detectLoop();\n    public Node middle();\n    public  swapNodes(int valueFirst, int valueSecond);\n    public Node reverseListIter(Node node);\n    public Node reverseListRec(Node head);\n    public  clear();\n    public boolean isEmpty();\n    public int size();\n    public Node getHead();\n    public  setHead(Node head);\n    public int count();\n    public boolean search(int key);\n    public String toString();\n    public  deleteDuplicates();\n    public  print();\n    public  insertHead(int x);\n    public  insert(int data);\n    public  insertNth(int data, int position);\n    public  deleteHead();\n    public  delete();\n    public  deleteNth(int position);\n    public int getNth(int index);\n    public  checkBounds(int position, int low, int high);\n    static public  main(String arg);\n    public Iterator<Integer> iterator();\n    private class SinglyLinkedListIterator implements Iterator<Integer> {\n        private Node current;\n        SinglyLinkedListIterator();\n        public boolean hasNext();\n        public Integer next();\n    }\n}\nclass Node {\n    int value;\n    Node next;\n    Node();\n    Node(int value);\n    Node(int value, Node next);\n}",
    "docstring": "/**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/Merge_K_SortedLinkedlist.java",
    "file_name": "Merge_K_SortedLinkedlist.java",
    "package": "com.thealgorithms.datastructures.lists",
    "class_name": "Merge_K_SortedLinkedlist",
    "method_name": "mergeKList",
    "source_code": "Node mergeKList(Node[] a, int N) {\n    // Min Heap\n    PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n    // adding head of all linkedList in min heap\n    min.addAll(Arrays.asList(a).subList(0, N));\n    // Make new head among smallest heads in K linkedList\n    Node head = min.poll();\n    min.add(head.next);\n    Node curr = head;\n    // merging LinkedList\n    while (!min.isEmpty()) {\n        Node temp = min.poll();\n        curr.next = temp;\n        curr = temp;\n        // Add Node in min Heap only if temp.next is not null\n        if (temp.next != null) {\n            min.add(temp.next);\n        }\n    }\n    return head;\n}",
    "context": "package com.thealgorithms.datastructures.lists;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\npublic class Merge_K_SortedLinkedlist {\n    Node mergeKList(Node a, int N);\n    private class Node {\n        private int data;\n        private Node next;\n    }\n}",
    "docstring": "/**\n     * This function merge K sorted LinkedList\n     *\n     * @param a array of LinkedList\n     * @param N size of array\n     * @return node\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
    "file_name": "FibonacciHeap.java",
    "package": "com.thealgorithms.datastructures.heaps",
    "class_name": "FibonacciHeap",
    "method_name": "insert",
    "source_code": "public HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}",
    "context": "package com.thealgorithms.datastructures.heaps;\npublic class FibonacciHeap {\n    static final private double GOLDEN_RATIO;\n    private HeapNode min;\n    static private int totalLinks;\n    static private int totalCuts;\n    private int numOfTrees;\n    private int numOfHeapNodes;\n    private int markedHeapNoodesCounter;\n    public FibonacciHeap();\n    public FibonacciHeap(int key);\n    public boolean empty();\n    public HeapNode insert(int key);\n    public  deleteMin();\n    public HeapNode findMin();\n    public  meld(FibonacciHeap heap2);\n    public int size();\n    public int[] countersRep();\n    public  delete(HeapNode x);\n    private  decreaseKey(HeapNode x, int delta);\n    public int potential();\n    static public int totalLinks();\n    static public int totalCuts();\n    private  updateMin(HeapNode posMin);\n    private  cascadingCuts(HeapNode curr);\n    private  cut(HeapNode curr);\n    private  successiveLink(HeapNode curr);\n    private HeapNode toBuckets(HeapNode curr);\n    private HeapNode fromBuckets(HeapNode buckets);\n    private HeapNode link(HeapNode c1, HeapNode c2);\n    public class HeapNode {\n        public int key;\n        private int rank;\n        private boolean marked;\n        private HeapNode child;\n        private HeapNode next;\n        private HeapNode prev;\n        private HeapNode parent;\n        public HeapNode(int key);\n        public int getKey();\n        private boolean isMarked();\n        private  mark();\n        private  setNext(HeapNode newNext);\n        private HeapNode getNext();\n        private boolean isRoot();\n    }\n}",
    "docstring": "/**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/ConnectedComponent.java",
    "file_name": "ConnectedComponent.java",
    "package": "com.thealgorithms.datastructures.graphs",
    "class_name": "Graph",
    "method_name": "countGraphs",
    "source_code": "public int countGraphs() {\n    int count = 0;\n    Set<Node> markedNodes = new HashSet<Node>();\n    for (Node n : nodeList) {\n        if (!markedNodes.contains(n)) {\n            markedNodes.add(n);\n            markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n            count++;\n        }\n    }\n    return count;\n}",
    "context": "package com.thealgorithms.datastructures.graphs;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\nclass Graph {\n    class Node {\n        E name;\n        public Node(E name);\n    }\n    class Edge {\n        Node startNode, endNode;\n        public Edge(Node startNode, Node endNode);\n    }\n    ArrayList<Edge> edgeList;\n    ArrayList<Node> nodeList;\n    public Graph();\n    public  addEdge(E startNode, E endNode);\n    public int countGraphs();\n    public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited);\n}\npublic class ConnectedComponent {\n    static public  main(String args);\n}",
    "docstring": "/**\n     * Main method used for counting the connected components. Iterates through\n     * the array of nodes to do a depth first search to get all nodes of the\n     * graph from the actual node. These nodes are added to the array\n     * markedNodes and will be ignored if they are chosen in the nodeList.\n     *\n     * @return returns the amount of unconnected graphs\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/KahnsAlgorithm.java",
    "file_name": "KahnsAlgorithm.java",
    "package": "com.thealgorithms.datastructures.graphs",
    "class_name": "KahnsAlgorithm",
    "method_name": "topSortOrder",
    "source_code": "ArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n    ArrayList<E> answer = new ArrayList<>();\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n    return answer;\n}",
    "context": "package com.thealgorithms.datastructures.graphs;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nclass AdjacencyList {\n    Map<E, ArrayList<E>> adj;\n    AdjacencyList();\n     addEdge(E from, E to);\n    ArrayList<E> getAdjacents(E v);\n    Set<E> getVertices();\n     printGraph();\n}\nclass TopologicalSort {\n    AdjacencyList<E> graph;\n    Map<E, Integer> inDegree;\n    TopologicalSort(AdjacencyList<E> graph);\n     calculateInDegree();\n    ArrayList<E> topSortOrder();\n}\npublic class KahnsAlgorithm {\n    static public  main(String args);\n}",
    "docstring": "/**\n     * Returns an ArrayList with vertices arranged in topological order\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java",
    "file_name": "NodeStack.java",
    "package": "com.thealgorithms.datastructures.stacks",
    "class_name": "NodeStack",
    "method_name": "push",
    "source_code": "public void push(Item item) {\n    NodeStack<Item> newNs = new NodeStack<Item>(item);\n    if (this.isEmpty()) {\n        NodeStack.setHead(new NodeStack<>(item));\n        newNs.setNext(null);\n        newNs.setPrevious(null);\n    } else {\n        newNs.setPrevious(NodeStack.head);\n        NodeStack.head.setNext(newNs);\n        NodeStack.setHead(newNs);\n    }\n    NodeStack.setSize(NodeStack.getSize() + 1);\n}",
    "context": "package com.thealgorithms.datastructures.stacks;\npublic class NodeStack {\n    static public  main(String args);\n    private Item data;\n    static private NodeStack<> head;\n    private NodeStack<> previous;\n    static private int size;\n    public NodeStack();\n    private NodeStack(Item item);\n    public  push(Item item);\n    public Item pop();\n    public Item peek();\n    public boolean isEmpty();\n    public int size();\n    public  print();\n    static private  setHead(NodeStack<> ns);\n    private  setNext(NodeStack<> next);\n    private NodeStack<> getPrevious();\n    private  setPrevious(NodeStack<> previous);\n    static private int getSize();\n    static private  setSize(int size);\n    private Item getData();\n}",
    "docstring": "/**\n     * Put a value onto the stack.\n     *\n     * @param item : value to be put on the stack.\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/stacks/StackArrayList.java",
    "file_name": "StackArrayList.java",
    "package": "com.thealgorithms.datastructures.stacks",
    "class_name": "StackArrayList",
    "method_name": "peek",
    "source_code": "public int peek() {\n    if (isEmpty()) {\n        throw new EmptyStackException();\n    }\n    return stack.get(stack.size() - 1);\n}",
    "context": "package com.thealgorithms.datastructures.stacks;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\npublic class StackArrayList {\n    static public  main(String args);\n    private ArrayList<Integer> stack;\n    public StackArrayList();\n    public  push(int value);\n    public int pop();\n    public boolean isEmpty();\n    public int peek();\n    public int size();\n}",
    "docstring": "/**\n     * Return the element at the top of this stack without removing it from the\n     * stack.\n     *\n     * @return the element at the top of this stack.\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/AbsoluteMax.java",
    "file_name": "AbsoluteMax.java",
    "package": "com.thealgorithms.maths",
    "class_name": "AbsoluteMax",
    "method_name": "getMaxValue",
    "source_code": "public static int getMaxValue(int... numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    int absMax = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n            absMax = numbers[i];\n        }\n    }\n    return absMax;\n}",
    "context": "package com.thealgorithms.maths;\npublic class AbsoluteMax {\n    static public int getMaxValue(int numbers);\n}",
    "docstring": "/**\n     * Finds the absolute maximum value among the given numbers.\n     *\n     * @param numbers The numbers to compare.\n     * @return The absolute maximum value.\n     * @throws IllegalArgumentException If the input array is empty or null.\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/AliquotSum.java",
    "file_name": "AliquotSum.java",
    "package": "com.thealgorithms.maths",
    "class_name": "AliquotSum",
    "method_name": "getAliquotSum",
    "source_code": "public static int getAliquotSum(int n) {\n    if (n <= 0) return -1;\n    int sum = 1;\n    double root = Math.sqrt(n);\n    /*\n     * We can get the factors after the root by dividing number by its factors\n     * before the root.\n     * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n     * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n     * Now by dividing 100 by each factor before 10 we get:\n     * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n     * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n     */\n    for (int i = 2; i <= root; i++) {\n        if (n % i == 0) {\n            sum += i + n / i;\n        }\n    }\n    // if n is a perfect square then its root was added twice in above loop, so subtracting root\n    // from sum\n    if (root == (int) root) sum -= root;\n    return sum;\n}",
    "context": "package com.thealgorithms.maths;\nimport java.util.stream.IntStream;\npublic class AliquotSum {\n    static public int getAliquotValue(int number);\n    static public int getAliquotSum(int n);\n}",
    "docstring": "/**\n     * Function to calculate the aliquot sum of an integer number\n     *\n     * @param n a positive integer\n     * @return aliquot sum of given {@code number}\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/Armstrong.java",
    "file_name": "Armstrong.java",
    "package": "com.thealgorithms.maths",
    "class_name": "Armstrong",
    "method_name": "isArmstrong",
    "source_code": "public boolean isArmstrong(int number) {\n    long sum = 0;\n    String temp = Integer.toString(number); // Convert the given number to a string\n    int power = temp.length(); // Extract the length of the number (number of digits)\n    long originalNumber = number;\n    while (originalNumber > 0) {\n        long digit = originalNumber % 10;\n        sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n        originalNumber /= 10;\n    }\n    return sum == number;\n}",
    "context": "package com.thealgorithms.maths;\npublic class Armstrong {\n    public boolean isArmstrong(int number);\n}",
    "docstring": "/**\n     * Checks whether a given number is an Armstrong number or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/Average.java",
    "file_name": "Average.java",
    "package": "com.thealgorithms.maths",
    "class_name": "Average",
    "method_name": "average",
    "source_code": "public static int average(int[] numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    long sum = 0;\n    for (int number : numbers) {\n        sum += number;\n    }\n    return (int) (sum / numbers.length);\n}",
    "context": "package com.thealgorithms.maths;\npublic class Average {\n    static public double average(double[] numbers);\n    static public int average(int[] numbers);\n}",
    "docstring": "/**\n     * find average value of an int array\n     *\n     * @param numbers the array contains element and the sum does not excess long\n     *                value limit\n     * @return average value\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "file_name": "FFT.java",
    "package": "com.thealgorithms.maths",
    "class_name": "FFT",
    "method_name": "fft",
    "source_code": "public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}",
    "context": "package com.thealgorithms.maths;\nimport java.util.ArrayList;\nimport java.util.Collections;\npublic class FFT {\n    static class Complex {\n        private double real, img;\n        public Complex();\n        public Complex(double r, double i);\n        public double getReal();\n        public double getImaginary();\n        public Complex add(Complex z);\n        public Complex subtract(Complex z);\n        public Complex multiply(Complex z);\n        public Complex multiply(double n);\n        public Complex conjugate();\n        public double abs();\n        public Complex divide(Complex z);\n        public Complex divide(double n);\n    }\n    static public ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse);\n    static public int findLog2(int N);\n    static public ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x);\n    static public ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x);\n    static private int reverseBits(int num, int log2N);\n    static private  paddingPowerOfTwo(ArrayList<Complex> x);\n}",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FindMax.java",
    "file_name": "FindMax.java",
    "package": "com.thealgorithms.maths",
    "class_name": "FindMax",
    "method_name": "findMax",
    "source_code": "public static int findMax(final int[] array) {\n    int n = array.length;\n    if (n == 0) {\n        throw new IllegalArgumentException(\"Array must be non-empty.\");\n    }\n    int max = array[0];\n    for (int i = 1; i < n; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}",
    "context": "package com.thealgorithms.maths;\nfinal public class FindMax {\n    private FindMax();\n    static public int findMax(int[] array);\n}",
    "docstring": "/**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/TwinPrime.java",
    "file_name": "TwinPrime.java",
    "package": "com.thealgorithms.maths",
    "class_name": "TwinPrime",
    "method_name": "getTwinPrime",
    "source_code": "static int getTwinPrime(int inputNumber) {\n    // if inputNumber and (inputNumber + 2) are both prime\n    // then return (inputNumber + 2) as a result\n    if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n        return inputNumber + 2;\n    }\n    // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n    // then return -1 as a result\n    return -1;\n}",
    "context": "package com.thealgorithms.maths;\npublic class TwinPrime {\n    static int getTwinPrime(int inputNumber);\n}",
    "docstring": "/**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/sorts/QuickSort.java",
    "file_name": "QuickSort.java",
    "package": "com.thealgorithms.sorts",
    "class_name": "QuickSort",
    "method_name": "sort",
    "source_code": "@Override\npublic <T extends Comparable<T>> T[] sort(T[] array) {\n    doSort(array, 0, array.length - 1);\n    return array;\n}",
    "context": "package com.thealgorithms.sorts;\nimport static com.thealgorithms.sorts.SortUtils;\nclass QuickSort implements SortAlgorithm {\n    public T sort(T array);\n    static private  doSort(T array, int left, int right);\n    static private int randomPartition(T array, int left, int right);\n    static private int partition(T array, int left, int right);\n}",
    "docstring": "/**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/sorts/HeapSort.java",
    "file_name": "HeapSort.java",
    "package": "com.thealgorithms.sorts",
    "class_name": "HeapSort",
    "method_name": "sort",
    "source_code": "@Override\npublic <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    int n = unsorted.length;\n    heapify(unsorted, n);\n    while (n > 1) {\n        swap(unsorted, 1, n--);\n        siftDown(unsorted, 1, n);\n    }\n    return unsorted;\n}",
    "context": "package com.thealgorithms.sorts;\npublic class HeapSort implements SortAlgorithm {\n    public T sort(T unsorted);\n    static private  heapify(T unsorted, int n);\n    static private  siftDown(T unsorted, int k, int n);\n    static private  swap(T array, int idx, int idy);\n    static private boolean less(T array, int idx, int idy);\n}",
    "docstring": "/**\n     * For simplicity, we are considering the heap root index as 1 instead of 0.\n     * It simplifies future calculations. Because of that we are decreasing the\n     * provided indexes by 1 in {@link #swap(Object[], int, int)} and\n     * {@link #less(Comparable[], int, int)} functions.\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/strings/HammingDistance.java",
    "file_name": "HammingDistance.java",
    "package": "com.thealgorithms.strings",
    "class_name": "HammingDistance",
    "method_name": "calculateHammingDistance",
    "source_code": "public static int calculateHammingDistance(String s1, String s2) throws Exception {\n    if (s1.length() != s2.length()) {\n        throw new Exception(\"String lengths must be equal\");\n    }\n    int stringLength = s1.length();\n    int counter = 0;\n    for (int i = 0; i < stringLength; i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            counter++;\n        }\n    }\n    return counter;\n}",
    "context": "package com.thealgorithms.strings;\npublic class HammingDistance {\n    static public int calculateHammingDistance(String s1, String s2)throws Exception;\n}",
    "docstring": "/**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */"
  },
  {
    "project_name": "Java",
    "relative_path": "Java/src/main/java/com/thealgorithms/strings/Lower.java",
    "file_name": "Lower.java",
    "package": "com.thealgorithms.strings",
    "class_name": "Lower",
    "method_name": "toLowerCase",
    "source_code": "public static String toLowerCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n        if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n            values[i] = Character.toLowerCase(values[i]);\n        }\n    }\n    return new String(values);\n}",
    "context": "package com.thealgorithms.strings;\npublic class Lower {\n    static public  main(String args);\n    static public String toLowerCase(String s);\n}",
    "docstring": "/**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */"
  },
  {
    "project_name": "JCTools",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
    "file_name": "NonBlockingHashMap.java",
    "package": "org.jctools.maps",
    "class_name": "NonBlockingHashMap",
    "method_name": "toString",
    "source_code": "@Override\npublic String toString() {\n  Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n  if( !i.hasNext())\n    return \"{}\";\n  StringBuilder sb = new StringBuilder();\n  sb.append('{');\n  for (;;) {\n    Entry<TypeK,TypeV> e = i.next();\n    TypeK key = e.getKey();\n    TypeV value = e.getValue();\n    sb.append(key   == this ? \"(this Map)\" : key);\n    sb.append('=');\n    sb.append(value == this ? \"(this Map)\" : value);\n    if( !i.hasNext())\n      return sb.append('}').toString();\n    sb.append(\", \");\n  }\n}",
    "context": "package org.jctools.maps;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport org.jctools.util.RangeUtil;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\npublic class NonBlockingHashMap extends AbstractMap<TypeK, TypeV> implements ConcurrentMap<TypeK, TypeV>, Cloneable, Serializable {\n    static final private long serialVersionUID;\n    static final private int REPROBE_LIMIT;\n    static final private int _Obase;\n    static final private int _Oscale;\n    static final private int _Olog;\n    static private long rawIndex(Object ary, int idx);\n    static final private long _kvs_offset;\n    final private boolean CAS_kvs(Object oldkvs, Object newkvs);\n    static final private class Prime {\n        final Object _V;\n        Prime(Object V);\n        static Object unbox(Object V);\n    }\n    static final private int hash(Object key);\n    transient private Object _kvs;\n    static final private CHM chm(Object kvs);\n    static final private int[] hashes(Object kvs);\n    static final private int len(Object kvs);\n    transient private long _last_resize_milli;\n    static final private int MIN_SIZE_LOG;\n    static final private int MIN_SIZE;\n    static final private Object NO_MATCH_OLD;\n    static final private Object MATCH_ANY;\n    static public final Object TOMBSTONE;\n    static final private Prime TOMBPRIME;\n    static final private Object key(Object kvs, int idx);\n    static final private Object val(Object kvs, int idx);\n    static final private boolean CAS_key(Object kvs, int idx, Object old, Object key);\n    static final private boolean CAS_val(Object kvs, int idx, Object old, Object val);\n    final public  print();\n    final private  print(Object kvs);\n    final private  print2(Object kvs);\n    transient private ConcurrentAutoTable _reprobes;\n    public long reprobes();\n    static private int reprobe_limit(int len);\n    public NonBlockingHashMap();\n    public NonBlockingHashMap(int initial_sz);\n    final private  initialize(int initial_sz);\n    protected final  initialize();\n    public int size();\n    public boolean isEmpty();\n    public boolean containsKey(Object key);\n    public boolean contains(Object val);\n    public TypeV put(TypeK key, TypeV val);\n    public TypeV putIfAbsent(TypeK key, TypeV val);\n    public TypeV remove(Object key);\n    public boolean remove(Object key, Object val);\n    public TypeV replace(TypeK key, TypeV val);\n    public boolean replace(TypeK key, TypeV oldValue, TypeV newValue);\n    static private boolean objectsEquals(Object a, Object b);\n    final public TypeV putIfMatchAllowNull(Object key, Object newVal, Object oldVal);\n    final public TypeV putIfMatch(Object key, Object newVal, Object oldVal);\n    public  putAll(Map<TypeK, TypeV> m);\n    public  clear();\n    public boolean containsValue(Object val);\n    protected  rehash();\n    public Object clone();\n    public String toString();\n    static private boolean keyeq(Object K, Object key, int[] hashes, int hash, int fullhash);\n    public TypeV get(Object key);\n    static final private Object get_impl(NonBlockingHashMap topmap, Object kvs, Object key);\n    public TypeK getk(TypeK key);\n    static final private Object getk_impl(NonBlockingHashMap topmap, Object kvs, Object key);\n    volatile static int DUMMY_VOLATILE;\n    static final private Object putIfMatch0(NonBlockingHashMap topmap, Object kvs, Object key, Object putval, Object expVal);\n    final private Object help_copy(Object helper);\n    static final private class CHM {\n        final private ConcurrentAutoTable _size;\n        public int size();\n        final private ConcurrentAutoTable _slots;\n        public int slots();\n        volatile Object _newkvs;\n        static final private AtomicReferenceFieldUpdater<CHM, Object> _newkvsUpdater;\n        boolean CAS_newkvs(Object newkvs);\n        volatile long _resizers;\n        static final private AtomicLongFieldUpdater<CHM> _resizerUpdater;\n        CHM(ConcurrentAutoTable size);\n        final private boolean tableFull(int reprobe_cnt, int len);\n        final private Object resize(NonBlockingHashMap topmap, Object kvs);\n        volatile long _copyIdx;\n        static final private AtomicLongFieldUpdater<CHM> _copyIdxUpdater;\n        volatile long _copyDone;\n        static final private AtomicLongFieldUpdater<CHM> _copyDoneUpdater;\n        final private  help_copy_impl(NonBlockingHashMap topmap, Object oldkvs, boolean copy_all);\n        final private Object copy_slot_and_check(NonBlockingHashMap topmap, Object oldkvs, int idx, Object should_help);\n        final private  copy_check_and_promote(NonBlockingHashMap topmap, Object oldkvs, int workdone);\n        private boolean copy_slot(NonBlockingHashMap topmap, int idx, Object oldkvs, Object newkvs);\n    }\n    private class SnapshotV implements Iterator<TypeV>, Enumeration<TypeV> {\n        final Object _sskvs;\n        public SnapshotV();\n        int length();\n        Object key(int idx);\n        private int _idx;\n        private Object _nextK, _prevK;\n        private TypeV _nextV, _prevV;\n        public boolean hasNext();\n        public TypeV next();\n        public  removeKey();\n        public  remove();\n        public TypeV nextElement();\n        public boolean hasMoreElements();\n    }\n    public Object raw_array();\n    public Enumeration<TypeV> elements();\n    public Collection<TypeV> values();\n    private class SnapshotK implements Iterator<TypeK>, Enumeration<TypeK> {\n        final SnapshotV _ss;\n        public SnapshotK();\n        public  remove();\n        public TypeK next();\n        public boolean hasNext();\n        public TypeK nextElement();\n        public boolean hasMoreElements();\n    }\n    public Enumeration<TypeK> keys();\n    public Set<TypeK> keySet();\n    private class NBHMEntry extends AbstractEntry<TypeK, TypeV> {\n        NBHMEntry(TypeK k, TypeV v);\n        public TypeV setValue(TypeV val);\n    }\n    private class SnapshotE implements Iterator<Map> {\n        final SnapshotV _ss;\n        public SnapshotE();\n        public  remove();\n        public Map next();\n        public boolean hasNext();\n    }\n    public Set<Map> entrySet();\n    private  writeObject(java s)throws IOException;\n    private  readObject(java s)throws IOException, ClassNotFoundException;\n}",
    "docstring": "/**\n   * Returns a string representation of this map.  The string representation\n   * consists of a list of key-value mappings in the order returned by the\n   * map's <tt>entrySet</tt> view's iterator, enclosed in braces\n   * (<tt>\"{}\"</tt>).  Adjacent mappings are separated by the characters\n   * <tt>\", \"</tt> (comma and space).  Each key-value mapping is rendered as\n   * the key followed by an equals sign (<tt>\"=\"</tt>) followed by the\n   * associated value.  Keys and values are converted to strings as by\n   * {@link String#valueOf(Object)}.\n   *\n   * @return a string representation of this map\n   */"
  },
  {
    "project_name": "JCTools",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/queues/BaseLinkedQueue.java",
    "file_name": "BaseLinkedQueue.java",
    "package": "org.jctools.queues",
    "class_name": "BaseLinkedQueuePad0",
    "method_name": "size",
    "source_code": "@Override\npublic final int size()\n{\n    // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n    LinkedQueueNode<E> chaserNode = lvConsumerNode();\n    LinkedQueueNode<E> producerNode = lvProducerNode();\n    int size = 0;\n    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n    while (chaserNode != producerNode && // don't go passed producer node\n        chaserNode != null && // stop at last node\n        size < Integer.MAX_VALUE) // stop at max int\n    {\n        LinkedQueueNode<E> next;\n        next = chaserNode.lvNext();\n        // check if this node has been consumed, if so return what we have\n        if (next == chaserNode)\n        {\n            return size;\n        }\n        chaserNode = next;\n        size++;\n    }\n    return size;\n}",
    "context": "package org.jctools.queues;\nimport java.util.AbstractQueue;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\nabstract class BaseLinkedQueuePad0 extends AbstractQueue<E> implements MessagePassingQueue<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n}\nabstract class BaseLinkedQueueProducerNodeRef extends BaseLinkedQueuePad0<E> {\n    static final long P_NODE_OFFSET;\n    volatile private LinkedQueueNode<E> producerNode;\n    final  spProducerNode(LinkedQueueNode<E> newValue);\n    final  soProducerNode(LinkedQueueNode<E> newValue);\n    final LinkedQueueNode<E> lvProducerNode();\n    final boolean casProducerNode(LinkedQueueNode<E> expect, LinkedQueueNode<E> newValue);\n    final LinkedQueueNode<E> lpProducerNode();\n}\nabstract class BaseLinkedQueuePad1 extends BaseLinkedQueueProducerNodeRef<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\nabstract class BaseLinkedQueueConsumerNodeRef extends BaseLinkedQueuePad1<E> {\n    static final private long C_NODE_OFFSET;\n    private LinkedQueueNode<E> consumerNode;\n    final  spConsumerNode(LinkedQueueNode<E> newValue);\n    final LinkedQueueNode<E> lvConsumerNode();\n    final LinkedQueueNode<E> lpConsumerNode();\n}\nabstract class BaseLinkedQueuePad2 extends BaseLinkedQueueConsumerNodeRef<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\nabstract class BaseLinkedQueue extends BaseLinkedQueuePad2<E> {\n    final public Iterator<E> iterator();\n    public String toString();\n    protected final LinkedQueueNode<E> newNode();\n    protected final LinkedQueueNode<E> newNode(E e);\n    final public int size();\n    public boolean isEmpty();\n    protected E getSingleConsumerNodeValue(LinkedQueueNode<E> currConsumerNode, LinkedQueueNode<E> nextNode);\n    public E poll();\n    public E peek();\n    LinkedQueueNode<E> spinWaitForNextNode(LinkedQueueNode<E> currNode);\n    public E relaxedPoll();\n    public E relaxedPeek();\n    public boolean relaxedOffer(E e);\n    public int drain(Consumer<E> c, int limit);\n    public int drain(Consumer<E> c);\n    public  drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit);\n    public int capacity();\n}",
    "docstring": "/**\n     * {@inheritDoc} <br>\n     * <p>\n     * IMPLEMENTATION NOTES:<br>\n     * This is an O(n) operation as we run through all the nodes and count them.<br>\n     * The accuracy of the value returned by this method is subject to races with producer/consumer threads. In\n     * particular when racing with the consumer thread this method may under estimate the size.<br>\n     *\n     * @see java.util.Queue#size()\n     */"
  },
  {
    "project_name": "JCTools",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/queues/BaseSpscLinkedArrayQueue.java",
    "file_name": "BaseSpscLinkedArrayQueue.java",
    "package": "org.jctools.queues",
    "class_name": "BaseSpscLinkedArrayQueuePrePad",
    "method_name": "offer",
    "source_code": "@Override\npublic boolean offer(final E e)\n{\n    // Objects.requireNonNull(e);\n    if (null == e)\n    {\n        throw new NullPointerException();\n    }\n    // local load of field to avoid repeated loads after volatile reads\n    final E[] buffer = producerBuffer;\n    final long index = lpProducerIndex();\n    final long mask = producerMask;\n    final long offset = calcCircularRefElementOffset(index, mask);\n    // expected hot path\n    if (index < producerBufferLimit)\n    {\n        writeToQueue(buffer, e, index, offset);\n        return true;\n    }\n    return offerColdPath(buffer, mask, index, offset, e, null);\n}",
    "context": "package org.jctools.queues;\nimport org.jctools.queues.IndexedQueueSizeUtil.IndexedQueue;\nimport org.jctools.util.PortableJvmInfo;\nimport java.util.AbstractQueue;\nimport java.util.Iterator;\nimport static org.jctools.queues.LinkedArrayQueueUtil.length;\nimport static org.jctools.queues.LinkedArrayQueueUtil.nextArrayOffset;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\nimport static org.jctools.util.UnsafeRefArrayAccess;\nabstract class BaseSpscLinkedArrayQueuePrePad extends AbstractQueue<E> implements IndexedQueue {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n}\nabstract class BaseSpscLinkedArrayQueueConsumerColdFields extends BaseSpscLinkedArrayQueuePrePad<E> {\n    protected long consumerMask;\n    protected E consumerBuffer;\n}\nabstract class BaseSpscLinkedArrayQueueConsumerField extends BaseSpscLinkedArrayQueueConsumerColdFields<E> {\n    static final private long C_INDEX_OFFSET;\n    volatile private long consumerIndex;\n    final public long lvConsumerIndex();\n    final long lpConsumerIndex();\n    final  soConsumerIndex(long newValue);\n}\nabstract class BaseSpscLinkedArrayQueueL2Pad extends BaseSpscLinkedArrayQueueConsumerField<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\nabstract class BaseSpscLinkedArrayQueueProducerFields extends BaseSpscLinkedArrayQueueL2Pad<E> {\n    static final private long P_INDEX_OFFSET;\n    volatile private long producerIndex;\n    final public long lvProducerIndex();\n    final  soProducerIndex(long newValue);\n    final long lpProducerIndex();\n}\nabstract class BaseSpscLinkedArrayQueueProducerColdFields extends BaseSpscLinkedArrayQueueProducerFields<E> {\n    protected long producerBufferLimit;\n    protected long producerMask;\n    protected E producerBuffer;\n}\nabstract class BaseSpscLinkedArrayQueue extends BaseSpscLinkedArrayQueueProducerColdFields<E> implements MessagePassingQueue<E>, QueueProgressIndicators {\n    static final private Object JUMP;\n    final public Iterator<E> iterator();\n    final public int size();\n    final public boolean isEmpty();\n    public String toString();\n    public long currentProducerIndex();\n    public long currentConsumerIndex();\n    protected final  soNext(E curr, E next);\n    protected final E lvNextArrayAndUnlink(E curr);\n    public boolean relaxedOffer(E e);\n    public E relaxedPoll();\n    public E relaxedPeek();\n    public int drain(Consumer<E> c);\n    public int fill(Supplier<E> s);\n    public int drain(Consumer<E> c, int limit);\n    public int fill(Supplier<E> s, int limit);\n    public  drain(Consumer<E> c, WaitStrategy wait, ExitCondition exit);\n    public  fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit);\n    public boolean offer(E e);\n    abstract boolean offerColdPath(E buffer, long mask, long pIndex, long offset, E v, Supplier<E> s);\n    public E poll();\n    public E peek();\n    final  linkOldToNew(long currIndex, E oldBuffer, long offset, E newBuffer, long offsetInNew, E e);\n    final  writeToQueue(E buffer, E e, long index, long offset);\n    private E newBufferPeek(E buffer, long index);\n    private E newBufferPoll(E buffer, long index);\n}",
    "docstring": "/**\n     * {@inheritDoc}\n     * <p>\n     * This implementation is correct for single producer thread use only.\n     */"
  },
  {
    "project_name": "jfreechart",
    "relative_path": "jfreechart/src/main/java/org/jfree/data/json/JSONUtils.java",
    "file_name": "JSONUtils.java",
    "package": "org.jfree.data.json",
    "class_name": "JSONUtils",
    "method_name": "writeKeyedValues",
    "source_code": "public static String writeKeyedValues(KeyedValues data) {\n    Args.nullNotPermitted(data, \"data\");\n    StringWriter sw = new StringWriter();\n    try {\n        writeKeyedValues(data, sw);\n    } catch (IOException ex) {\n        throw new RuntimeException(ex);\n    }\n    return sw.toString();\n}",
    "context": "package org.jfree.data.json;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.KeyedValues2D;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.PieDataset;\nimport org.jfree.data.json.impl.JSONValue;\npublic class JSONUtils {\n    static public String writeKeyedValues(KeyedValues data);\n    static public  writeKeyedValues(KeyedValues data, Writer writer)throws IOException;\n    static public String writeKeyedValues2D(KeyedValues2D data);\n    static public  writeKeyedValues2D(KeyedValues2D data, Writer writer)throws IOException;\n}",
    "docstring": "/**\n     * Returns a string containing the data in JSON format.  The format is\n     * an array of arrays, where each sub-array represents one data value.\n     * The sub-array should contain two items, first the item key as a string\n     * and second the item value as a number.  For example:\n     * {@code [[\"Key A\", 1.0], [\"Key B\", 2.0]]}\n     * <br><br>\n     * Note that this method can be used with instances of {@link PieDataset}.\n     * \n     * @param data  the data ({@code null} not permitted).\n     * \n     * @return A string in JSON format. \n     */"
  },
  {
    "project_name": "jfreechart",
    "relative_path": "jfreechart/src/main/java/org/jfree/data/statistics/BoxAndWhiskerCalculator.java",
    "file_name": "BoxAndWhiskerCalculator.java",
    "package": "org.jfree.data.statistics",
    "class_name": "BoxAndWhiskerCalculator",
    "method_name": "calculateQ1",
    "source_code": "public static double calculateQ1(List values) {\n    Args.nullNotPermitted(values, \"values\");\n    double result = Double.NaN;\n    int count = values.size();\n    if (count > 0) {\n        if (count % 2 == 1) {\n            if (count > 1) {\n                result = Statistics.calculateMedian(values, 0, count / 2);\n            }\n            else {\n                result = Statistics.calculateMedian(values, 0, 0);\n            }\n        }\n        else {\n            result = Statistics.calculateMedian(values, 0, count / 2 - 1);\n        }\n    }\n    return result;\n}",
    "context": "package org.jfree.data.statistics;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jfree.chart.util.Args;\nabstract public class BoxAndWhiskerCalculator {\n    static public BoxAndWhiskerItem calculateBoxAndWhiskerStatistics(List values);\n    static public BoxAndWhiskerItem calculateBoxAndWhiskerStatistics(List values, boolean stripNullAndNaNItems);\n    static public double calculateQ1(List values);\n    static public double calculateQ3(List values);\n}",
    "docstring": "/**\n     * Calculates the first quartile for a list of numbers in ascending order.\n     * If the items in the list are not in ascending order, the result is\n     * unspecified.  If the list contains items that are {@code null}, not\n     * an instance of {@code Number}, or equivalent to\n     * {@code Double.NaN}, the result is unspecified.\n     *\n     * @param values  the numbers in ascending order ({@code null} not\n     *     permitted).\n     *\n     * @return The first quartile.\n     */"
  },
  {
    "project_name": "jfreechart",
    "relative_path": "jfreechart/src/main/java/org/jfree/data/statistics/Regression.java",
    "file_name": "Regression.java",
    "package": "org.jfree.data.statistics",
    "class_name": "Regression",
    "method_name": "getPowerRegression",
    "source_code": "public static double[] getPowerRegression(double[][] data) {\n    int n = data.length;\n    if (n < 2) {\n        throw new IllegalArgumentException(\"Not enough data.\");\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        double x = Math.log(data[i][0]);\n        double y = Math.log(data[i][1]);\n        sumX += x;\n        sumY += y;\n        double xx = x * x;\n        sumXX += xx;\n        double xy = x * y;\n        sumXY += xy;\n    }\n    double sxx = sumXX - (sumX * sumX) / n;\n    double sxy = sumXY - (sumX * sumY) / n;\n    double xbar = sumX / n;\n    double ybar = sumY / n;\n    double[] result = new double[2];\n    result[1] = sxy / sxx;\n    result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n    return result;\n}",
    "context": "package org.jfree.data.statistics;\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.xy.XYDataset;\nabstract public class Regression {\n    static public double[] getOLSRegression(double[][] data);\n    static public double[] getOLSRegression(XYDataset data, int series);\n    static public double[] getPowerRegression(double[][] data);\n    static public double[] getPowerRegression(XYDataset data, int series);\n    static public double[] getPolynomialRegression(XYDataset dataset, int series, int order);\n    static private double[][] calculateSubMatrix(double[][] matrix);\n}",
    "docstring": "/**\n     * Returns the parameters 'a' and 'b' for an equation y = ax^b, fitted to\n     * the data using a power regression equation.  The result is returned as\n     * an array, where double[0] --&gt; a, and double[1] --&gt; b.\n     *\n     * @param data  the data.\n     *\n     * @return The parameters.\n     */"
  },
  {
    "project_name": "jfreechart",
    "relative_path": "jfreechart/src/main/java/org/jfree/data/statistics/Regression.java",
    "file_name": "Regression.java",
    "package": "org.jfree.data.statistics",
    "class_name": "Regression",
    "method_name": "calculateSubMatrix",
    "source_code": "private static double[][] calculateSubMatrix(double[][] matrix){\n    int equations = matrix.length;\n    int coefficients = matrix[0].length;\n    double[][] result = new double[equations - 1][coefficients - 1];\n    for (int eq = 1; eq < equations; eq++) {\n        double factor = matrix[0][0] / matrix[eq][0];\n        for (int coe = 1; coe < coefficients; coe++) {\n            result[eq - 1][coe -1] = matrix[0][coe] - matrix[eq][coe]\n                    * factor;\n        }\n    }\n    if (equations == 1) {\n        return result;\n    }\n    // check for zero pivot element\n    if (result[0][0] == 0) {\n        boolean found = false;\n        for (int i = 0; i < result.length; i ++) {\n            if (result[i][0] != 0) {\n                found = true;\n                double[] temp = result[0];\n                System.arraycopy(result[i], 0, result[0], 0, \n                        result[i].length);\n                System.arraycopy(temp, 0, result[i], 0, temp.length);\n                break;\n            }\n        }\n        if (!found) {\n            //System.out.println(\"Equation has no solution!\");\n            return new double[equations - 1][coefficients - 1];\n        }\n    }\n    double[][] subMatrix = calculateSubMatrix(result);\n    for (int eq = 1; eq < equations -  1; eq++) {\n        result[eq][0] = 0;\n        if (coefficients - 1 - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, result[eq], 1, coefficients - 1 - 1);\n    }\n    return result;\n}",
    "context": "package org.jfree.data.statistics;\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.xy.XYDataset;\nabstract public class Regression {\n    static public double[] getOLSRegression(double[][] data);\n    static public double[] getOLSRegression(XYDataset data, int series);\n    static public double[] getPowerRegression(double[][] data);\n    static public double[] getPowerRegression(XYDataset data, int series);\n    static public double[] getPolynomialRegression(XYDataset dataset, int series, int order);\n    static private double[][] calculateSubMatrix(double[][] matrix);\n}",
    "docstring": "/**\n     * Returns a matrix with the following features: (1) the number of rows\n     * and columns is 1 less than that of the original matrix; (2)the matrix\n     * is triangular, i.e. all elements a (row, column) with column &gt; row are\n     * zero.  This method is used for calculating a polynomial regression.\n     * \n     * @param matrix  the start matrix.\n     *\n     * @return The new matrix.\n     */"
  },
  {
    "project_name": "jfreechart",
    "relative_path": "jfreechart/src/main/java/org/jfree/data/general/DatasetUtils.java",
    "file_name": "DatasetUtils.java",
    "package": "org.jfree.data.general",
    "class_name": "DatasetUtils",
    "method_name": "calculatePieDatasetTotal",
    "source_code": "public static double calculatePieDatasetTotal(PieDataset dataset) {\n    Args.nullNotPermitted(dataset, \"dataset\");\n    List keys = dataset.getKeys();\n    double totalValue = 0;\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable current = (Comparable) iterator.next();\n        if (current != null) {\n            Number value = dataset.getValue(current);\n            double v = 0.0;\n            if (value != null) {\n                v = value.doubleValue();\n            }\n            if (v > 0) {\n                totalValue = totalValue + v;\n            }\n        }\n    }\n    return totalValue;\n}",
    "context": "package org.jfree.data.general;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jfree.chart.util.ArrayUtils;\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.DomainOrder;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\nimport org.jfree.data.xy.XYZDataset;\nfinal public class DatasetUtils {\n    private DatasetUtils();\n    static public double calculatePieDatasetTotal(PieDataset dataset);\n    static public PieDataset createPieDatasetForRow(CategoryDataset dataset, Comparable rowKey);\n    static public PieDataset createPieDatasetForRow(CategoryDataset dataset, int row);\n    static public PieDataset createPieDatasetForColumn(CategoryDataset dataset, Comparable columnKey);\n    static public PieDataset createPieDatasetForColumn(CategoryDataset dataset, int column);\n    static public PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent);\n    static public PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent, int minItems);\n    static public CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, double[][] data);\n    static public CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, Number data);\n    static public CategoryDataset createCategoryDataset(Comparable rowKeys, Comparable columnKeys, double[][] data);\n    static public CategoryDataset createCategoryDataset(Comparable rowKey, KeyedValues rowData);\n    static public XYDataset sampleFunction2D(Function2D f, double start, double end, int samples, Comparable seriesKey);\n    static public XYSeries sampleFunction2DToSeries(Function2D f, double start, double end, int samples, Comparable seriesKey);\n    static public boolean isEmptyOrNull(PieDataset dataset);\n    static public boolean isEmptyOrNull(CategoryDataset dataset);\n    static public boolean isEmptyOrNull(XYDataset dataset);\n    static public Range findDomainBounds(XYDataset dataset);\n    static public Range findDomainBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range iterateDomainBounds(XYDataset dataset);\n    static public Range iterateDomainBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findRangeBounds(CategoryDataset dataset);\n    static public Range findRangeBounds(CategoryDataset dataset, boolean includeInterval);\n    static public Range findRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range findRangeBounds(XYDataset dataset);\n    static public Range findRangeBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Range iterateRangeBounds(CategoryDataset dataset);\n    static public Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval);\n    static public Range iterateToFindRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range iterateRangeBounds(XYDataset dataset);\n    static public Range iterateRangeBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findZBounds(XYZDataset dataset);\n    static public Range findZBounds(XYZDataset dataset, boolean includeInterval);\n    static public Range findZBounds(XYZDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Range iterateZBounds(XYZDataset dataset);\n    static public Range iterateZBounds(XYZDataset dataset, boolean includeInterval);\n    static public Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Range iterateToFindZBounds(XYZDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Number findMinimumDomainValue(XYDataset dataset);\n    static public Number findMaximumDomainValue(XYDataset dataset);\n    static public Number findMinimumRangeValue(CategoryDataset dataset);\n    static public Number findMinimumRangeValue(XYDataset dataset);\n    static public Number findMaximumRangeValue(CategoryDataset dataset);\n    static public Number findMaximumRangeValue(XYDataset dataset);\n    static public Range findStackedRangeBounds(CategoryDataset dataset);\n    static public Range findStackedRangeBounds(CategoryDataset dataset, double base);\n    static public Range findStackedRangeBounds(CategoryDataset dataset, KeyToGroupMap map);\n    static public Number findMinimumStackedRangeValue(CategoryDataset dataset);\n    static public Number findMaximumStackedRangeValue(CategoryDataset dataset);\n    static public Range findStackedRangeBounds(TableXYDataset dataset);\n    static public Range findStackedRangeBounds(TableXYDataset dataset, double base);\n    static public double calculateStackTotal(TableXYDataset dataset, int item);\n    static public Range findCumulativeRangeBounds(CategoryDataset dataset);\n    static public double findYValue(XYDataset dataset, int series, double x);\n    static public int[] findItemIndicesForX(XYDataset dataset, int series, double x);\n}",
    "docstring": "/**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or {@code null} values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The total.\n     */"
  },
  {
    "project_name": "jfreechart",
    "relative_path": "jfreechart/src/main/java/org/jfree/data/general/Series.java",
    "file_name": "Series.java",
    "package": "org.jfree.data.general",
    "class_name": "Series",
    "method_name": "equals",
    "source_code": "@Override\npublic boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Series)) {\n        return false;\n    }\n    Series that = (Series) obj;\n    if (!Objects.equals(this.key, that.key)) {\n        return false;\n    }\n    if (!Objects.equals(this.description, that.description)) {\n        return false;\n    }\n    if (!that.canEqual(this)) {\n        return false;\n    }\n    return true;\n}",
    "context": "package org.jfree.data.general;\nimport org.jfree.chart.util.Args;\nimport javax.swing.event.EventListenerList;\nimport java.beans;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Objects;\nabstract public class Series implements Cloneable, Serializable {\n    static final private long serialVersionUID;\n    private Comparable key;\n    private String description;\n    transient private EventListenerList listeners;\n    transient private PropertyChangeSupport propertyChangeSupport;\n    transient private VetoableChangeSupport vetoableChangeSupport;\n    private boolean notify;\n    protected Series(Comparable key);\n    protected Series(Comparable key, String description);\n    public Comparable getKey();\n    public  setKey(Comparable key);\n    public String getDescription();\n    public  setDescription(String description);\n    public boolean getNotify();\n    public  setNotify(boolean notify);\n    public boolean isEmpty();\n    abstract public int getItemCount();\n    public Object clone()throws CloneNotSupportedException;\n    public boolean equals(Object obj);\n    public boolean canEqual(Object other);\n    public int hashCode();\n    public  addChangeListener(SeriesChangeListener listener);\n    public  removeChangeListener(SeriesChangeListener listener);\n    public  fireSeriesChanged();\n    protected  notifyListeners(SeriesChangeEvent event);\n    public  addPropertyChangeListener(PropertyChangeListener listener);\n    public  removePropertyChangeListener(PropertyChangeListener listener);\n    protected  firePropertyChange(String property, Object oldValue, Object newValue);\n    public  addVetoableChangeListener(VetoableChangeListener listener);\n    public  removeVetoableChangeListener(VetoableChangeListener listener);\n    protected  fireVetoableChange(String property, Object oldValue, Object newValue)throws PropertyVetoException;\n    private  writeObject(ObjectOutputStream stream)throws IOException;\n    private  readObject(ObjectInputStream stream)throws IOException, ClassNotFoundException;\n}",
    "docstring": "/**\n     * Tests the series for equality with another object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "file_name": "Decoder.java",
    "package": "com.google.zxing.aztec.decoder",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "source_code": "private static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}",
    "context": "package com.google.zxing.aztec.decoder;\nimport com.google.zxing.FormatException;\nimport com.google.zxing.aztec.AztecDetectorResult;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.common.CharacterSetECI;\nimport com.google.zxing.common.DecoderResult;\nimport com.google.zxing.common.reedsolomon.GenericGF;\nimport com.google.zxing.common.reedsolomon.ReedSolomonDecoder;\nimport com.google.zxing.common.reedsolomon.ReedSolomonException;\nimport java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nfinal public class Decoder {\n    private enum Table{UPPER, LOWER, MIXED, DIGIT, PUNCT, BINARY}\n    static final private String UPPER_TABLE;\n    static final private String LOWER_TABLE;\n    static final private String MIXED_TABLE;\n    static final private String PUNCT_TABLE;\n    static final private String DIGIT_TABLE;\n    static final private Charset DEFAULT_ENCODING;\n    private AztecDetectorResult ddata;\n    public DecoderResult decode(AztecDetectorResult detectorResult)throws FormatException;\n    static public String highLevelDecode(boolean[] correctedBits)throws FormatException;\n    static private String getEncodedData(boolean[] correctedBits)throws FormatException;\n    static private Table getTable(char t);\n    static private String getCharacter(Table table, int code);\n    static final class CorrectedBitsResult {\n        final private boolean[] correctBits;\n        final private int errorsCorrected;\n        final private int ecLevel;\n        CorrectedBitsResult(boolean[] correctBits, int errorsCorrected, int ecLevel);\n    }\n    private CorrectedBitsResult correctBits(boolean[] rawbits)throws FormatException;\n    private boolean[] extractBits(BitMatrix matrix);\n    static private int readCode(boolean[] rawbits, int startIndex, int length);\n    static private byte readByte(boolean[] rawbits, int startIndex);\n    static byte[] convertBoolArrayToByteArray(boolean[] boolArr);\n    static private int totalBitsInLayer(int layers, boolean compact);\n}",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "file_name": "Decoder.java",
    "package": "com.google.zxing.aztec.decoder",
    "class_name": "Decoder",
    "method_name": "getCharacter",
    "source_code": "private static String getCharacter(Table table, int code) {\n  switch (table) {\n    case UPPER:\n      return UPPER_TABLE[code];\n    case LOWER:\n      return LOWER_TABLE[code];\n    case MIXED:\n      return MIXED_TABLE[code];\n    case PUNCT:\n      return PUNCT_TABLE[code];\n    case DIGIT:\n      return DIGIT_TABLE[code];\n    default:\n      // Should not reach here.\n      throw new IllegalStateException(\"Bad table\");\n  }\n}",
    "context": "package com.google.zxing.aztec.decoder;\nimport com.google.zxing.FormatException;\nimport com.google.zxing.aztec.AztecDetectorResult;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.common.CharacterSetECI;\nimport com.google.zxing.common.DecoderResult;\nimport com.google.zxing.common.reedsolomon.GenericGF;\nimport com.google.zxing.common.reedsolomon.ReedSolomonDecoder;\nimport com.google.zxing.common.reedsolomon.ReedSolomonException;\nimport java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nfinal public class Decoder {\n    private enum Table{UPPER, LOWER, MIXED, DIGIT, PUNCT, BINARY}\n    static final private String UPPER_TABLE;\n    static final private String LOWER_TABLE;\n    static final private String MIXED_TABLE;\n    static final private String PUNCT_TABLE;\n    static final private String DIGIT_TABLE;\n    static final private Charset DEFAULT_ENCODING;\n    private AztecDetectorResult ddata;\n    public DecoderResult decode(AztecDetectorResult detectorResult)throws FormatException;\n    static public String highLevelDecode(boolean[] correctedBits)throws FormatException;\n    static private String getEncodedData(boolean[] correctedBits)throws FormatException;\n    static private Table getTable(char t);\n    static private String getCharacter(Table table, int code);\n    static final class CorrectedBitsResult {\n        final private boolean[] correctBits;\n        final private int errorsCorrected;\n        final private int ecLevel;\n        CorrectedBitsResult(boolean[] correctBits, int errorsCorrected, int ecLevel);\n    }\n    private CorrectedBitsResult correctBits(boolean[] rawbits)throws FormatException;\n    private boolean[] extractBits(BitMatrix matrix);\n    static private int readCode(boolean[] rawbits, int startIndex, int length);\n    static private byte readByte(boolean[] rawbits, int startIndex);\n    static byte[] convertBoolArrayToByteArray(boolean[] boolArr);\n    static private int totalBitsInLayer(int layers, boolean compact);\n}",
    "docstring": "/**\n   * Gets the character (or string) corresponding to the passed code in the given table\n   *\n   * @param table the table used\n   * @param code the code of the character\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/detector/Detector.java",
    "file_name": "Detector.java",
    "package": "com.google.zxing.aztec.detector",
    "class_name": "Detector",
    "method_name": "detect",
    "source_code": "public AztecDetectorResult detect(boolean isMirror) throws NotFoundException {\n  // 1. Get the center of the aztec matrix\n  Point pCenter = getMatrixCenter();\n  // 2. Get the center points of the four diagonal points just outside the bull's eye\n  //  [topRight, bottomRight, bottomLeft, topLeft]\n  ResultPoint[] bullsEyeCorners = getBullsEyeCorners(pCenter);\n  if (isMirror) {\n    ResultPoint temp = bullsEyeCorners[0];\n    bullsEyeCorners[0] = bullsEyeCorners[2];\n    bullsEyeCorners[2] = temp;\n  }\n  // 3. Get the size of the matrix and other parameters from the bull's eye\n  int errorsCorrected = extractParameters(bullsEyeCorners);\n  // 4. Sample the grid\n  BitMatrix bits = sampleGrid(image,\n                              bullsEyeCorners[shift % 4],\n                              bullsEyeCorners[(shift + 1) % 4],\n                              bullsEyeCorners[(shift + 2) % 4],\n                              bullsEyeCorners[(shift + 3) % 4]);\n  // 5. Get the corners of the matrix.\n  ResultPoint[] corners = getMatrixCornerPoints(bullsEyeCorners);\n  return new AztecDetectorResult(bits, corners, compact, nbDataBlocks, nbLayers, errorsCorrected);\n}",
    "context": "package com.google.zxing.aztec.detector;\nimport com.google.zxing.NotFoundException;\nimport com.google.zxing.ResultPoint;\nimport com.google.zxing.aztec.AztecDetectorResult;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.common.GridSampler;\nimport com.google.zxing.common.detector.MathUtils;\nimport com.google.zxing.common.detector.WhiteRectangleDetector;\nimport com.google.zxing.common.reedsolomon.GenericGF;\nimport com.google.zxing.common.reedsolomon.ReedSolomonDecoder;\nimport com.google.zxing.common.reedsolomon.ReedSolomonException;\nfinal public class Detector {\n    static final private int[] EXPECTED_CORNER_BITS;\n    final private BitMatrix image;\n    private boolean compact;\n    private int nbLayers;\n    private int nbDataBlocks;\n    private int nbCenterLayers;\n    private int shift;\n    public Detector(BitMatrix image);\n    public AztecDetectorResult detect()throws NotFoundException;\n    public AztecDetectorResult detect(boolean isMirror)throws NotFoundException;\n    private int extractParameters(ResultPoint bullsEyeCorners)throws NotFoundException;\n    static private int getRotation(int[] sides, int length)throws NotFoundException;\n    static private CorrectedParameter getCorrectedParameterData(long parameterData, boolean compact)throws NotFoundException;\n    private ResultPoint getBullsEyeCorners(Point pCenter)throws NotFoundException;\n    private Point getMatrixCenter();\n    private ResultPoint getMatrixCornerPoints(ResultPoint bullsEyeCorners);\n    private BitMatrix sampleGrid(BitMatrix image, ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomRight, ResultPoint bottomLeft)throws NotFoundException;\n    private int sampleLine(ResultPoint p1, ResultPoint p2, int size);\n    private boolean isWhiteOrBlackRectangle(Point p1, Point p2, Point p3, Point p4);\n    private int getColor(Point p1, Point p2);\n    private Point getFirstDifferent(Point init, boolean color, int dx, int dy);\n    static private ResultPoint expandSquare(ResultPoint cornerPoints, int oldSide, int newSide);\n    private boolean isValid(int x, int y);\n    private boolean isValid(ResultPoint point);\n    static private float distance(Point a, Point b);\n    static private float distance(ResultPoint a, ResultPoint b);\n    private int getDimension();\n    static final class Point {\n        final private int x;\n        final private int y;\n        ResultPoint toResultPoint();\n        Point(int x, int y);\n        int getX();\n        int getY();\n        public String toString();\n    }\n    static final class CorrectedParameter {\n        final private int data;\n        final private int errorsCorrected;\n        CorrectedParameter(int data, int errorsCorrected);\n        int getData();\n        int getErrorsCorrected();\n    }\n}",
    "docstring": "/**\n   * Detects an Aztec Code in an image.\n   *\n   * @param isMirror if true, image is a mirror-image of original\n   * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n   * @throws NotFoundException if no Aztec Code can be found\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/detector/Detector.java",
    "file_name": "Detector.java",
    "package": "com.google.zxing.aztec.detector",
    "class_name": "Detector",
    "method_name": "getMatrixCenter",
    "source_code": "private Point getMatrixCenter() {\n  ResultPoint pointA;\n  ResultPoint pointB;\n  ResultPoint pointC;\n  ResultPoint pointD;\n  //Get a white rectangle that can be the border of the matrix in center bull's eye or\n  try {\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n  } catch (NotFoundException e) {\n    // This exception can be in case the initial rectangle is white\n    // In that case, surely in the bull's eye, we try to expand the rectangle.\n    int cx = image.getWidth() / 2;\n    int cy = image.getHeight() / 2;\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n  }\n  //Compute the center of the rectangle\n  int cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  int cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n  // Redetermine the white rectangle starting from previously computed center.\n  // This will ensure that we end up with a white rectangle in center bull's eye\n  // in order to compute a more accurate center.\n  try {\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image, 15, cx, cy).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n  } catch (NotFoundException e) {\n    // This exception can be in case the initial rectangle is white\n    // In that case we try to expand the rectangle.\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n  }\n  // Recompute the center of the rectangle\n  cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n  return new Point(cx, cy);\n}",
    "context": "package com.google.zxing.aztec.detector;\nimport com.google.zxing.NotFoundException;\nimport com.google.zxing.ResultPoint;\nimport com.google.zxing.aztec.AztecDetectorResult;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.common.GridSampler;\nimport com.google.zxing.common.detector.MathUtils;\nimport com.google.zxing.common.detector.WhiteRectangleDetector;\nimport com.google.zxing.common.reedsolomon.GenericGF;\nimport com.google.zxing.common.reedsolomon.ReedSolomonDecoder;\nimport com.google.zxing.common.reedsolomon.ReedSolomonException;\nfinal public class Detector {\n    static final private int[] EXPECTED_CORNER_BITS;\n    final private BitMatrix image;\n    private boolean compact;\n    private int nbLayers;\n    private int nbDataBlocks;\n    private int nbCenterLayers;\n    private int shift;\n    public Detector(BitMatrix image);\n    public AztecDetectorResult detect()throws NotFoundException;\n    public AztecDetectorResult detect(boolean isMirror)throws NotFoundException;\n    private int extractParameters(ResultPoint bullsEyeCorners)throws NotFoundException;\n    static private int getRotation(int[] sides, int length)throws NotFoundException;\n    static private CorrectedParameter getCorrectedParameterData(long parameterData, boolean compact)throws NotFoundException;\n    private ResultPoint getBullsEyeCorners(Point pCenter)throws NotFoundException;\n    private Point getMatrixCenter();\n    private ResultPoint getMatrixCornerPoints(ResultPoint bullsEyeCorners);\n    private BitMatrix sampleGrid(BitMatrix image, ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomRight, ResultPoint bottomLeft)throws NotFoundException;\n    private int sampleLine(ResultPoint p1, ResultPoint p2, int size);\n    private boolean isWhiteOrBlackRectangle(Point p1, Point p2, Point p3, Point p4);\n    private int getColor(Point p1, Point p2);\n    private Point getFirstDifferent(Point init, boolean color, int dx, int dy);\n    static private ResultPoint expandSquare(ResultPoint cornerPoints, int oldSide, int newSide);\n    private boolean isValid(int x, int y);\n    private boolean isValid(ResultPoint point);\n    static private float distance(Point a, Point b);\n    static private float distance(ResultPoint a, ResultPoint b);\n    private int getDimension();\n    static final class Point {\n        final private int x;\n        final private int y;\n        ResultPoint toResultPoint();\n        Point(int x, int y);\n        int getX();\n        int getY();\n        public String toString();\n    }\n    static final class CorrectedParameter {\n        final private int data;\n        final private int errorsCorrected;\n        CorrectedParameter(int data, int errorsCorrected);\n        int getData();\n        int getErrorsCorrected();\n    }\n}",
    "docstring": "/**\n   * Finds a candidate center point of an Aztec code from an image\n   *\n   * @return the center point\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/encoder/Encoder.java",
    "file_name": "Encoder.java",
    "package": "com.google.zxing.aztec.encoder",
    "class_name": "Encoder",
    "method_name": "encode",
    "source_code": "public static AztecCode encode(String data, int minECCPercent, int userSpecifiedLayers, Charset charset) {\n  byte[] bytes = data.getBytes(null != charset ? charset : StandardCharsets.ISO_8859_1);\n  return encode(bytes, minECCPercent, userSpecifiedLayers, charset);\n}",
    "context": "package com.google.zxing.aztec.encoder;\nimport com.google.zxing.common.BitArray;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.common.reedsolomon.GenericGF;\nimport com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nfinal public class Encoder {\n    static public final int DEFAULT_EC_PERCENT;\n    static public final int DEFAULT_AZTEC_LAYERS;\n    static final private int MAX_NB_BITS;\n    static final private int MAX_NB_BITS_COMPACT;\n    static final private int[] WORD_SIZE;\n    private Encoder();\n    static public AztecCode encode(String data);\n    static public AztecCode encode(String data, int minECCPercent, int userSpecifiedLayers);\n    static public AztecCode encode(String data, int minECCPercent, int userSpecifiedLayers, Charset charset);\n    static public AztecCode encode(byte[] data);\n    static public AztecCode encode(byte[] data, int minECCPercent, int userSpecifiedLayers);\n    static public AztecCode encode(byte[] data, int minECCPercent, int userSpecifiedLayers, Charset charset);\n    static private  drawBullsEye(BitMatrix matrix, int center, int size);\n    static BitArray generateModeMessage(boolean compact, int layers, int messageSizeInWords);\n    static private  drawModeMessage(BitMatrix matrix, boolean compact, int matrixSize, BitArray modeMessage);\n    static private BitArray generateCheckWords(BitArray bitArray, int totalBits, int wordSize);\n    static private int[] bitsToWords(BitArray stuffedBits, int wordSize, int totalWords);\n    static private GenericGF getGF(int wordSize);\n    static BitArray stuffBits(BitArray bits, int wordSize);\n    static private int totalBitsInLayer(int layers, boolean compact);\n}",
    "docstring": "/**\n   * Encodes the given string content as an Aztec symbol\n   *\n   * @param data input data string\n   * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n   *                      a minimum of 23% + 3 words is recommended)\n   * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n   * @param charset character set in which to encode string using ECI; if null, no ECI code\n   *                will be inserted, and the string must be encodable as ISO/IEC 8859-1\n   *                (Latin-1), the default encoding of the symbol.\n   * @return Aztec symbol matrix with metadata\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/detector/MathUtils.java",
    "file_name": "MathUtils.java",
    "package": "com.google.zxing.common.detector",
    "class_name": "MathUtils",
    "method_name": "distance",
    "source_code": "public static float distance(int aX, int aY, int bX, int bY) {\n  double xDiff = aX - bX;\n  double yDiff = aY - bY;\n  return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n}",
    "context": "package com.google.zxing.common.detector;\nfinal public class MathUtils {\n    private MathUtils();\n    static public int round(float d);\n    static public float distance(float aX, float aY, float bX, float bY);\n    static public float distance(int aX, int aY, int bX, int bY);\n    static public int sum(int[] array);\n}",
    "docstring": "/**\n   * @param aX point A x coordinate\n   * @param aY point A y coordinate\n   * @param bX point B x coordinate\n   * @param bY point B y coordinate\n   * @return Euclidean distance between points A and B\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/detector/WhiteRectangleDetector.java",
    "file_name": "WhiteRectangleDetector.java",
    "package": "com.google.zxing.common.detector",
    "class_name": "WhiteRectangleDetector",
    "method_name": "detect",
    "source_code": "public ResultPoint[] detect() throws NotFoundException {\n  int left = leftInit;\n  int right = rightInit;\n  int up = upInit;\n  int down = downInit;\n  boolean sizeExceeded = false;\n  boolean aBlackPointFoundOnBorder = true;\n  boolean atLeastOneBlackPointFoundOnRight = false;\n  boolean atLeastOneBlackPointFoundOnBottom = false;\n  boolean atLeastOneBlackPointFoundOnLeft = false;\n  boolean atLeastOneBlackPointFoundOnTop = false;\n  while (aBlackPointFoundOnBorder) {\n    aBlackPointFoundOnBorder = false;\n    // .....\n    // .   |\n    // .....\n    boolean rightBorderNotWhite = true;\n    while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n      rightBorderNotWhite = containsBlackPoint(up, down, right, false);\n      if (rightBorderNotWhite) {\n        right++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnRight = true;\n      } else if (!atLeastOneBlackPointFoundOnRight) {\n        right++;\n      }\n    }\n    if (right >= width) {\n      sizeExceeded = true;\n      break;\n    }\n    // .....\n    // .   .\n    // .___.\n    boolean bottomBorderNotWhite = true;\n    while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n      bottomBorderNotWhite = containsBlackPoint(left, right, down, true);\n      if (bottomBorderNotWhite) {\n        down++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnBottom = true;\n      } else if (!atLeastOneBlackPointFoundOnBottom) {\n        down++;\n      }\n    }\n    if (down >= height) {\n      sizeExceeded = true;\n      break;\n    }\n    // .....\n    // |   .\n    // .....\n    boolean leftBorderNotWhite = true;\n    while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n      leftBorderNotWhite = containsBlackPoint(up, down, left, false);\n      if (leftBorderNotWhite) {\n        left--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnLeft = true;\n      } else if (!atLeastOneBlackPointFoundOnLeft) {\n        left--;\n      }\n    }\n    if (left < 0) {\n      sizeExceeded = true;\n      break;\n    }\n    // .___.\n    // .   .\n    // .....\n    boolean topBorderNotWhite = true;\n    while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n      topBorderNotWhite = containsBlackPoint(left, right, up, true);\n      if (topBorderNotWhite) {\n        up--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnTop = true;\n      } else if (!atLeastOneBlackPointFoundOnTop) {\n        up--;\n      }\n    }\n    if (up < 0) {\n      sizeExceeded = true;\n      break;\n    }\n  }\n  if (!sizeExceeded) {\n    int maxSize = right - left;\n    ResultPoint z = null;\n    for (int i = 1; z == null && i < maxSize; i++) {\n      z = getBlackPointOnSegment(left, down - i, left + i, down);\n    }\n    if (z == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    ResultPoint t = null;\n    //go down right\n    for (int i = 1; t == null && i < maxSize; i++) {\n      t = getBlackPointOnSegment(left, up + i, left + i, up);\n    }\n    if (t == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    ResultPoint x = null;\n    //go down left\n    for (int i = 1; x == null && i < maxSize; i++) {\n      x = getBlackPointOnSegment(right, up + i, right - i, up);\n    }\n    if (x == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    ResultPoint y = null;\n    //go up left\n    for (int i = 1; y == null && i < maxSize; i++) {\n      y = getBlackPointOnSegment(right, down - i, right - i, down);\n    }\n    if (y == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    return centerEdges(y, z, x, t);\n  } else {\n    throw NotFoundException.getNotFoundInstance();\n  }\n}",
    "context": "package com.google.zxing.common.detector;\nimport com.google.zxing.NotFoundException;\nimport com.google.zxing.ResultPoint;\nimport com.google.zxing.common.BitMatrix;\nfinal public class WhiteRectangleDetector {\n    static final private int INIT_SIZE;\n    static final private int CORR;\n    final private BitMatrix image;\n    final private int height;\n    final private int width;\n    final private int leftInit;\n    final private int rightInit;\n    final private int downInit;\n    final private int upInit;\n    public WhiteRectangleDetector(BitMatrix image);\n    public WhiteRectangleDetector(BitMatrix image, int initSize, int x, int y);\n    public ResultPoint detect()throws NotFoundException;\n    private ResultPoint getBlackPointOnSegment(float aX, float aY, float bX, float bY);\n    private ResultPoint centerEdges(ResultPoint y, ResultPoint z, ResultPoint x, ResultPoint t);\n    private boolean containsBlackPoint(int a, int b, int fixed, boolean horizontal);\n}",
    "docstring": "/**\n   * <p>\n   * Detects a candidate barcode-like rectangular region within an image. It\n   * starts around the center of the image, increases the size of the candidate\n   * region until it finds a white rectangular region.\n   * </p>\n   *\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/reedsolomon/ReedSolomonDecoder.java",
    "file_name": "ReedSolomonDecoder.java",
    "package": "com.google.zxing.common.reedsolomon",
    "class_name": "ReedSolomonDecoder",
    "method_name": "decodeWithECCount",
    "source_code": "public int decodeWithECCount(int[] received, int twoS) throws ReedSolomonException {\n  GenericGFPoly poly = new GenericGFPoly(field, received);\n  int[] syndromeCoefficients = new int[twoS];\n  boolean noError = true;\n  for (int i = 0; i < twoS; i++) {\n    int eval = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n    syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;\n    if (eval != 0) {\n      noError = false;\n    }\n  }\n  if (noError) {\n    return 0;\n  }\n  GenericGFPoly syndrome = new GenericGFPoly(field, syndromeCoefficients);\n  GenericGFPoly[] sigmaOmega =\n      runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n  GenericGFPoly sigma = sigmaOmega[0];\n  GenericGFPoly omega = sigmaOmega[1];\n  int[] errorLocations = findErrorLocations(sigma);\n  int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);\n  for (int i = 0; i < errorLocations.length; i++) {\n    int position = received.length - 1 - field.log(errorLocations[i]);\n    if (position < 0) {\n      throw new ReedSolomonException(\"Bad error location\");\n    }\n    received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n  }\n  return errorLocations.length;\n}",
    "context": "package com.google.zxing.common.reedsolomon;\nfinal public class ReedSolomonDecoder {\n    final private GenericGF field;\n    public ReedSolomonDecoder(GenericGF field);\n    public  decode(int[] received, int twoS)throws ReedSolomonException;\n    public int decodeWithECCount(int[] received, int twoS)throws ReedSolomonException;\n    private GenericGFPoly runEuclideanAlgorithm(GenericGFPoly a, GenericGFPoly b, int R)throws ReedSolomonException;\n    private int[] findErrorLocations(GenericGFPoly errorLocator)throws ReedSolomonException;\n    private int[] findErrorMagnitudes(GenericGFPoly errorEvaluator, int[] errorLocations);\n}",
    "docstring": "/**\n   * <p>Decodes given set of received codewords, which include both data and error-correction\n   * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\n   * in the input.</p>\n   *\n   * @param received data and error-correction codewords\n   * @param twoS number of error-correction codewords available\n   * @return the number of errors corrected\n   * @throws ReedSolomonException if decoding fails for any reason\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/BitArray.java",
    "file_name": "BitArray.java",
    "package": "com.google.zxing.common",
    "class_name": "BitArray",
    "method_name": "getNextSet",
    "source_code": "public int getNextSet(int from) {\n  if (from >= size) {\n    return size;\n  }\n  int bitsOffset = from / 32;\n  int currentBits = bits[bitsOffset];\n  // mask off lesser bits first\n  currentBits &= -(1 << (from & 0x1F));\n  while (currentBits == 0) {\n    if (++bitsOffset == bits.length) {\n      return size;\n    }\n    currentBits = bits[bitsOffset];\n  }\n  int result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n  return Math.min(result, size);\n}",
    "context": "package com.google.zxing.common;\nimport java.util.Arrays;\nfinal public class BitArray implements Cloneable {\n    static final private int[] EMPTY_BITS;\n    static final private float LOAD_FACTOR;\n    private int[] bits;\n    private int size;\n    public BitArray();\n    public BitArray(int size);\n    BitArray(int[] bits, int size);\n    public int getSize();\n    public int getSizeInBytes();\n    private  ensureCapacity(int newSize);\n    public boolean get(int i);\n    public  set(int i);\n    public  flip(int i);\n    public int getNextSet(int from);\n    public int getNextUnset(int from);\n    public  setBulk(int i, int newBits);\n    public  setRange(int start, int end);\n    public  clear();\n    public boolean isRange(int start, int end, boolean value);\n    public  appendBit(boolean bit);\n    public  appendBits(int value, int numBits);\n    public  appendBitArray(BitArray other);\n    public  xor(BitArray other);\n    public  toBytes(int bitOffset, byte[] array, int offset, int numBytes);\n    public int[] getBitArray();\n    public  reverse();\n    static private int[] makeArray(int size);\n    public boolean equals(Object o);\n    public int hashCode();\n    public String toString();\n    public BitArray clone();\n}",
    "docstring": "/**\n   * @param from first bit to check\n   * @return index of first bit that is set, starting from the given index, or size if none are set\n   *  at or beyond this given index\n   * @see #getNextUnset(int)\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/HybridBinarizer.java",
    "file_name": "HybridBinarizer.java",
    "package": "com.google.zxing.common",
    "class_name": "HybridBinarizer",
    "method_name": "calculateThresholdForBlock",
    "source_code": "private static void calculateThresholdForBlock(byte[] luminances,\n                                               int subWidth,\n                                               int subHeight,\n                                               int width,\n                                               int height,\n                                               int[][] blackPoints,\n                                               BitMatrix matrix) {\n  int maxYOffset = height - BLOCK_SIZE;\n  int maxXOffset = width - BLOCK_SIZE;\n  for (int y = 0; y < subHeight; y++) {\n    int yoffset = y << BLOCK_SIZE_POWER;\n    if (yoffset > maxYOffset) {\n      yoffset = maxYOffset;\n    }\n    int top = cap(y, subHeight - 3);\n    for (int x = 0; x < subWidth; x++) {\n      int xoffset = x << BLOCK_SIZE_POWER;\n      if (xoffset > maxXOffset) {\n        xoffset = maxXOffset;\n      }\n      int left = cap(x, subWidth - 3);\n      int sum = 0;\n      for (int z = -2; z <= 2; z++) {\n        int[] blackRow = blackPoints[top + z];\n        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n      }\n      int average = sum / 25;\n      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n    }\n  }\n}",
    "context": "package com.google.zxing.common;\nimport com.google.zxing.Binarizer;\nimport com.google.zxing.LuminanceSource;\nimport com.google.zxing.NotFoundException;\nfinal public class HybridBinarizer extends GlobalHistogramBinarizer {\n    static final private int BLOCK_SIZE_POWER;\n    static final private int BLOCK_SIZE;\n    static final private int BLOCK_SIZE_MASK;\n    static final private int MINIMUM_DIMENSION;\n    static final private int MIN_DYNAMIC_RANGE;\n    private BitMatrix matrix;\n    public HybridBinarizer(LuminanceSource source);\n    public BitMatrix getBlackMatrix()throws NotFoundException;\n    public Binarizer createBinarizer(LuminanceSource source);\n    static private  calculateThresholdForBlock(byte[] luminances, int subWidth, int subHeight, int width, int height, int[][] blackPoints, BitMatrix matrix);\n    static private int cap(int value, int max);\n    static private  thresholdBlock(byte[] luminances, int xoffset, int yoffset, int threshold, int stride, BitMatrix matrix);\n    static private int[][] calculateBlackPoints(byte[] luminances, int subWidth, int subHeight, int width, int height);\n}",
    "docstring": "/**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */"
  },
  {
    "project_name": "zxing",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/pdf417/PDF417Common.java",
    "file_name": "PDF417Common.java",
    "package": "com.google.zxing.pdf417",
    "class_name": "PDF417Common",
    "method_name": "getCodeword",
    "source_code": "public static int getCodeword(int symbol) {\n  int i = Arrays.binarySearch(SYMBOL_TABLE, symbol & 0x3FFFF);\n  if (i < 0) {\n    return -1;\n  }\n  return (CODEWORD_TABLE[i] - 1) % NUMBER_OF_CODEWORDS;\n}",
    "context": "package com.google.zxing.pdf417;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport com.google.zxing.common.detector.MathUtils;\nfinal public class PDF417Common {\n    static public final int NUMBER_OF_CODEWORDS;\n    static public final int MAX_CODEWORDS_IN_BARCODE;\n    static public final int MIN_ROWS_IN_BARCODE;\n    static public final int MAX_ROWS_IN_BARCODE;\n    static public final int MODULES_IN_CODEWORD;\n    static public final int MODULES_IN_STOP_PATTERN;\n    static public final int BARS_IN_MODULE;\n    static final private int[] EMPTY_INT_ARRAY;\n    private PDF417Common();\n    static public int getBitCountSum(int[] moduleBitCount);\n    static public int[] toIntArray(Collection<Integer> list);\n    static public int getCodeword(int symbol);\n    static public final int[] SYMBOL_TABLE;\n    static final private int[] CODEWORD_TABLE;\n}",
    "docstring": "/**\n   * @param symbol encoded symbol to translate to a codeword\n   * @return the codeword corresponding to the symbol.\n   */"
  }
]